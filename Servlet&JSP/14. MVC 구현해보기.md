# MVC

MVC 패턴을 만들기 위해서는 Model, View, Controller 영역으로 분리해야한다.  
디렉토리 구조

- Controller (Servlet)
  - 클라이언트가 어떤 요청을하든 무조건 컨트롤러에 가도록(단순 페이지 로딩조차도)
  - java src파일 밑에 controller 패키지에 생성
  - HttpServlet을 상속받는 클래스를 생성
  - @WebServlet("/주소")로 서블릿 주소를 매핑해준다.(혹은 web.xml에서 설정 둘중 하나만)
- View (jsp)
  - WebContent 폴더에 jsp파일 형태로 존재
  - 주소 단계만큼 폴더가 있어야함 (/a/b.jsp 라면 WebContet의 하위 폴더 a폴더에 위치)
- Model (순수 자바)
  - Dto: 데이터 전달을 위한 클래스 model 패키지에
    - MemberDto.java
    - Dto가 없어도 구현은 가능하지만, Dto의 멤버를 전부 Service 함수 인자로 전달하는건 너무 코딩량이 많아지고 유지보수에 불편함, 묶어서 보낼수있는 Dto를 쓰자!
  - Dao: DB와 관련된 JDBC 구현 클래스 model.dao 패키지에
    - 인터페이스 MemberDao.java
    - 인터페이스를 상속받는 실제 구현 MemberDaoImpl.java
    - Impl객체는 하나만 있어도 되니까 **싱글톤패턴**을 적용하자!!
    - Dao호출로만 해결할수있는 문제라도, 컨트롤러에서 다이렉트로 Dao 호출하지 말고 무조건 Service를 거쳐 호출하는게 좋다.(유지보수와 통일성을 위해)
  - Service: 그 외 모든 서비스 관련 자바 코드 model.service 패키지에
    - 인터페이스 MemberService.java
    - 인터페이스를 상속받는 실제구현 MemberServiceImpl.java
    - Impl객체는 하나만 있어도 되니까 **싱글톤패턴**을 적용하자!!
    - Dao를 쓰려면 무조건 Service에서 호출하게 만들자, Dao는 DB만 관리할수있게

## 왜 DAO와 Service는 Interface를 따로 두고 상속받아 Impl를 구현하죠?

---

Service인터페이스 ServiceImpl로 나누는 이유

1. Loose Coupling 객체 간의 결합도를 낮추어 변화에 유연한 개발을 하기 위해서이다. 하나의 인터페이스를 구현하는 여러 구현체가 있고 기능에 따라 적절한 구현체가 들어가서 다형성을 주기 위함이다. 또 하나의 인터페이스만 바라보니 의존관계도 줄일 수 있다.

2. Spring 에서 JDK Dynamic Proxy 를 사용하여 AOP Proxy 를 만드는 만들기 위해 JDK Dynamic Proxy는 인터페이스 기반으로 프록시 객체를 만들게 되어 있다. 예를 들어, 인터페이스가 있어야지 @Transactional 어노테이션이 동작하게 된다.

하지만 특정 버전부터 CGLIB 라이브러리를 사용하여, 클래스 기반으로 AOP Proxy 를 만들도록 지원을 하게 되었다. 그래서 개발자는 AOP Proxy를 만드는 방식을 선택을 할 수 있게 되었다.

(CGLIB는 코드 생성 라이브러리로서(Code Generator Library) 런타임에 동적으로 자바 클래스의 프록시를 생성해주는 기능을 제공한다. CGLIB를 사용하면 매우 쉽게 프록시 객체를 생성할 수 있으며, 성능 또한 우수하다. 더불어, 인터페이스가 아닌 클래스에 대해서 동적 프록시를 생성할 수 있기 때문에 다양한 프로젝트에서 널리 사용되고 있다. 예를 들어, Hibernate는 자바빈 객체에 대한 프록시를 생성할 때 CGLIB를 사용하며, Spring은 프록시 기반의 AOP를 구현할 때 CGLIB를 사용하고 있다)

---

스프링에서 AOP를 구현할 때 처음에는 JdkDynamicProxy 를 사용했습니다. 이 프록시는 인터페이스가 없으면 사용할 수 없습니다. 지금에야 Objenesis 같은 인터페이스 제약 없는 프록시가 있지만 그 때는 선택지가 없어 구현체가 하나라도 인터페이스를 사용해야 했습니다. 그게 관습이 되어 내려오고 있습니다.

이론상으로 위와 같은 Service, ServiceImpl 패턴으로 설계를 해야하는 이유는 인터페이스와 구현체를 분리함으로써 구현체를 독립적으로 확장할 수 있으며, 구현체 클래스를 변경하거나 확장해도 이를 사용하는 클라이언트의 코드에 영향을 주지 않도록 하기 위함입니다.

---

이 같은 추상화를 통한 구현 방식은 객체지향의 특징 중 하나인 다형성과 객체지향의 다섯 가지 원칙 중 하나인 OCP 원칙을 가장 잘 실현해주는 설계 방식이라고 할 수 있습니다.

하지만 실제로 대부분의 프로젝트에서는 인터페이스와 구현체 클래스 사이의 관계가 1:1의 관계로 구성되어 실질적으로 인터페이스, 클래스 구조를 사용하는 것에 대한 이점을 전혀 가져가지 못함에도 불구하고 관습적으로 이러한 추상 패턴을 적용하고 있습니다.

- OCP (Open Closed Principle)

개방, 폐쇄 원칙이라고 하며 '소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.'는 프로그래밍 원칙입니다.

- 위 추상화를 통한 구현 방식의 단점

코드 구조가 복잡해지고, 복잡해진 구조 만큼 코드를 분석하고 확인하는 과정에서 인터페이스를 거쳐 구현체들을 확인해야 하는 번거로움이 생길 수 있습니다.

## 계속 인터페이스를 유지하는 관습적인 코딩을 해야하는가?

비록 스프링에서도 굳이 인터페이스 기반으로 하지 않아도 작동하게 할수있지만,

1. 객체에 대한 설계와 이를 구현한 코드는 언제든지 변할 수 있습니다. 그렇기 때문에 개발자는 이를 대비해야 합니다.
   지금 만들어서 사용중인 인터페이스와 구현체 클래스가 1:1 관계를 맺고 있을지 모르지만 서비스가 커지고 변화함에 따라서 얼마든지 구현체 클래스는 확장될 가능성을 가지고 있습니다. 그렇기 때문에 이러한 구조를 통해 미래의 변화에 유연하게 대처할 수 있도록 대비해야 합니다.
2. 이러한 구조는 협업에서 이점으로 작용될 수 있습니다.
   프로젝트를 시작할 때 설계자가 프로젝트의 큰 뼈대를 구성하고, 나머지 작업자들은 그에 맞는 실제 구현을 하게 되는 경우가 있습니다. 이때 함수명, 리턴, 파라미터 등을 설계자가 만들어놓은 인터페이스에 맞춰 코딩할 수 있습니다. 이처럼 인터페이스를 누군가 작성하고 실제 구현은 다른 사람이 할 수 있는 분할의 기능도 협업에서의 이점이 될 수 있습니다.
3. 어쨌든 기본적으로 인터페이스는 구현에 반드시 있어야 하는 부분을 강요할수 있기 때문에 추가 개발에도 인터페이스를 참고해서 생성하게 한다면, 일일히 뭘 구현해야할지 직접 찾아볼 필요가 없다.

## 중간중간 Exception 처리

```java
request.setAttribute("msg","에러 메시지 내용");

```

try-catch에서 error.jsp로 보내기전에 msg에 에러에 따라 표시해줄 내용을 넣는다.  
그 다음 error.jsp로 forward 시켜준다.
