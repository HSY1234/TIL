# AOP(Aspect Oriented Programming)

핵심 관심 사항과 공통(부가) 관심 사항.

- 핵심 관심 사항(core concern)과 공통 관심 사항(cross-cutting concern).
- 핵심 관심사항이란 없으면 안되는 기능(실제 서비스등)
- 기존 OOP에서는 공통관심사항을 여러 모듈에서 적용하는데 있어 중복된 코드를 양상 하는 한계가 존재함. 이를 해결하기 위해 AOP가 등장.
- 공통 관심사항의 예시) 로깅처리
- Aspect Oriented Programming은 문제를 해결하기 위한 핵심 관심 사항과 전체에 적용되는 공통 관심 사항을 기준으로 프로그래밍함으로써 공통 모듈을 손쉽게 적용할 수 있게 함.

## AOP의 개요

- AOP는 application에서의 관심사의 분리(기능의 분리) 즉, 핵심적인 기능에서 부가적인 기능을 분리한다.
- 분리한 부가기능을 어스펙트(Aspect)라는 독특한 모듈 형태로 만들어서 설계하고 개발하는 방법.
- OOP를 적용하여도 핵심기능에서 부가기능을 쉽게 분리된 모듈로 작성하기 어려운 문제점을 AOP가 해결.
- AOP는 부가기능을 어스펙트(Aspect)로 정의하여, 핵심기능에서 부가기능을 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있도록 도와주는 개념.

## 중복된 코드를 양상 하는 한계 예시

메소드가 수행되는데 얼마의 시간이 걸리는 지 알고싶다!

```java
public void a(){
  startTime = system.nano();
  메소드 내용
  endTime = system.nano();

  sysout = endTime- startTime;
}

public void b(){
  startTime = system.nano();
  메소드 내용
  endTime = system.nano();

  sysout = endTime- startTime;
}

```

위의 예시 처럼 공통 코드가 계속 겹친다! => 메소드로 빼면 되지 않음? 빼내기 힘듬!

## AOP 예시

간단한 메소드의 성능 검사

- 개발 도중 특히 DB에 다향의 데이터를 넣고 빼는 등의 배치 작업에 대하여 시간을 측정해 보고 쿼리를 개선하는 작업은 매우 의미가 있다. 이 경우 매번 해당 메소드의 처음과 끝에 `System.currentTimeMillis();` 를 사용하거나, 스프링이 제공하는 StopWatch코드를 사용하기는 매우 번거롭다.
- 이런 경우 해당 작업을 하는 코드를 밖에서 설정하고 해당 부분을 사용하는 것이 편리하다.

트랜잭션 처리

- 트랜잭션의 경우 비즈니스 로직의 전후에 설정된다.
- 하지만 매번 사용하는 트랜잭션(try{ ~~~ }catch{}부분)의 코드는 번거롭고, 소스를 더욱 복잡하게 보여준다.

예외 처리

- 스프링에는 DataAccessException이라는 매우 잘 정의되어 있는 예외 계층 구조가 있다.
- 예전 하이버네이트 예외들은 몇 개 없었고 그나마도 UncatchedException이 아니었다
- 이렇게 구조가 별로 안 좋은 예외들이 발생했을 때, 그걸 잡아서 잘 정의 되어있는 예외 계층 구조로 변환해서 다시 던지는 Aspect는 제 3의 프레임워크를 사용할 때, 본인의 프레임워크나 애플리케이션에서 별도의 예외 계층 구조로 변환하고 싶을 때 유용하다

아키텍처 검증

기타

- 하이버네이트와 JDBC를 같이 사용할 경우, DB 동기화 문제 해결
- 멀티쓰레드 Safety 관련하여 작업해야 하는 경우, 메소드들에 일괄적으로 락을 설정하는 Aspect
- 데드락등으로 인한 PessimisticLockingFailureException등의 예외를 만났을 때 재시도하는 Aspect
- 로깅, 인증, 권한등

## AOP 구조

![](img/AOP%20%EA%B5%AC%EC%A1%B0.png)

- 핵심 관심 사항: aaaService, bbbService, cccService....
- 공통 관심 사항: Security, Transaction, Other...

어떤 서비스에 어떤 공통관심사항을 쓸지 안쓸지 취사선택이 가능하다.  
즉 한군데서만 쓰는 기능이면 굳이 공통 관심 사항으로 뺄 필요가 없다.
위 그림 처럼 필요한 서비스 레이어에 가로지르는 느낌이라고 생각하면 된다.

## AOP 용어

Target

- 핵심기능을 담고 있는 모듈로 target은 부가기능을 부여할 대상이 됨.
- 예시) 입금서비스, 출금서비스, 이자서비스

Advice

- 어느 **시점**(Ex : method의 수행 전/후, 예외 발생 후 등..)에 어떤 공통 관심 기능(Aspect)을 적용할지 정의한 것. Target에 제공할 부가기능을 담고 있는 모듈
- 예시) 보안 Aspect는 입금, 출금, 이자 전에 적용되어야한다. 트랜잭션 처리는 입금, 출금, 이자 끝나고 처리해야한다.
- 시점의 예로 시작 전(=before), 정상종료 후(=afterReturning, JAVA에서 try안에 있다고 생각), 예외발생(=afterThrowing, JAVA에서 catch), 정상종료 & 예외 상관없이 언제나 종료 후(=after, JAVA에서 finally), 시간측정처럼 시작과 끝을 감싸야하는 경우(=around)

JoinPoint

- Aspect가 적용 될 수 있는 **지점**(method, field(Spring에서는 필드에서 못함, AOP는 스프링에 국한된 개념이 아니라서 다른 프레임워크나 언어에도 있다))
- 즉 target 객체가 구현한 인터페이스의 모든 method는 JoinPoint가 됨.
- 예시) 입금, 출금, 이자는 모두 함수니까 가능

Pointcut

- 공통 관심 사항이 적용될 JoinPoint.
- Advice를 적용할 target의 method를 선별하는 정규 표현식.
- Pointcut 표현식은 execution으로 시작하고 method의 Signature를 비교하는 방법을 주로 이용.
- Joinpoint는 Pointcut이 될수 있는 후보군, 실제 호출이 된 것을 Pointcut이라고 한다.

Aspect

- 여러 객체에서 공통으로 적용되는 공통 관심 사항. (transaction, logging, security..)
- AOP의 기본 모듈.
- Aspect = Advice + Pointcut.
- Aspect는 Singleton 형태의 객체로 존재(스프링이 알아서 해줌)

Advisor

- Advisor = Advice + pointcut.
- Advisor는 Spring AOP에서만 사용되는 특별한 용어.

Weaving

- 어떤 Advice를 어떤 Pointcut(핵심사항)에 적용시킬 것인지에 대한 설정(Advisor)
- 즉 Pointcut에 의해서 결정된 타겟의 JoinPoint에 부가기능(Advice)을 삽입하는 과정을 뜻함.
- Weaving은 AOP의 핵심기능(Target)의 코드에 영향을 주지 않으면서 필요한 부가기능(Advice)을 추가할수 있도록 해주는 핵심적인 처리과정.

## Pointcut 표현식

다양한 예시들이 있지만 몇가지 대표적인 예시, 정규표현식을 좀 더 공부할것  
앞에 public private를 사실상 생략하는 이유는 private는 어차피 못써서 다 public이므로

| pointcut                                             | 선택된 Jointpoints                                            |
| ---------------------------------------------------- | ------------------------------------------------------------- |
| execution(public \* \* (..))                         | public 메소드 실행                                            |
| execution(\* set\*(..))                              | 이름이 set으로 시작하는 모든 메소드 실행                      |
| execution(\* com.test.service.AccountService.\*(..)) | AccountService 인터페이스의 모든 메소드 실행                  |
| execution(\* com.test.service.\*.\*(..))             | service 패키지의 모든 클래스(하위 패키지X)의 모든 메소드 실행 |
| execution(\* com.test.service..\*.\*(..))            | service 패키지와 하위 패키지의 모든 메소드 실행               |

## AOP 적용 전후

![](img/AOP%20%EC%A0%84%ED%9B%84.PNG)

기존

- 하나의 어플리케이션안에 핵심과 공통을 같이 넣어뒀다

AOP 적용후

- 핵심(Primary)이 여러개 있고, 공통(Cross-Cutting)을 밖으로 빼놓는다
- Aspect를 각 핵심에 Weaving한다

## Spring AOP 특징

Spring은 프록시(Proxy) 기반 AOP를 지원.

- Spring은 Target 객체에 대한 Proxy를 만들어 제공.
- Target을 감싸는 Proxy는 실행시간(Runtime)에 생성.
- Proxy는 Advice를 Target 객체에 적용하면서 생성되는 객체.

프록시(Proxy)가 호출을 가로챈다 (Intercept)

- Proxy는 Target 객체에 대한 호출을 가로챈 다음 Advice의 부가기능 로직을 수행하고 난 후에 Target의 핵심 기능 로직을 호출한다.(전처리 Advice)
- 또는 Target의 핵심 기능 로직 method를 호출한 후에 부가기능(Advice)을 수행하는 경우도 있다.(후처리 Advice)

Spring AOP는 method JoinPoint만 지원.(필드 X)

- Spring은 동적 Proxy를 기반으로 AOP를 구현하므로 method JoinPoint만 지원한다.
- 즉, 핵심기능(Target)의 method가 호출되는 런타임 시점에만 부가기능(Advice)를 적용할 수 있다.
- 반면 AspectJ 같은 고급 AOP framework를 사용하면 객체의 생성, 필드값의 조회와 조작, static method 호출 및 초기화 등의 다양한 작업에 부가기능을 적용할 수 있다.

## AOP 구현방법

- POJO Class를 이용한 AOP 구현.
- Spring API를 이용한 AOP 구현.
- Annotation을 이용한 AOP구현.

## POJO기반 AOP 구현
