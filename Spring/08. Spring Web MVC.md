# Spring Web MVC

JSP에서 구현했던 MVC 패턴을 Spring으로 넘어가보자!!

## MVC 패턴

Model

- 어플리케이션 상태의 캡슐화.
- 상태 쿼리에 대한 응답.
- 어플리케이션의 기능 표현.
- 변경을 view에 통지.

View

- 모델을 화면에 시각적으로 표현.
- 모델에게 업데이트 요청.
- 사용자의 입력을 컨트롤러에 전달.
- 컨트롤러가 view를 선택하도록 허용.

Controller

- 어플리케이션의 행위 정의.
- 사용자 액션을 모델 업데이트와 mapping.
- 응답에 대한 view 선택 .

어플리케이션의 확장을 위해 Model, View, Controller 세가지 영역으로 분리.

- 컴포넌트의 변경이 다른 영역 컴포넌트에 영향을 미치지 않음(유지보수 용이).
- 컴포넌트 간의 결합성이 낮아 프로그램 수정이 용이(확장성이 뛰어남).
- 장점
  - 화면과 비즈니스 로직을 분리해서 작업 가능.
  - 영역별 개발로 인하여 확장성이 뛰어남.
  - 표준화된 코드를 사용하므로 공동작업이 용이하고 유지보수성이 좋음.
- 단점
  - 개발과정이 복잡해 초기 개발속도가 늦음.
  - 초보자가 이해하고 개발하기에 다소 어려움.

## Spring MVC의 특징

- Spring은 DI나 AOP같은 기능 뿐만이 아니라, Servlet 기반의 Web개발을 위한 MVC Framework 제공
  - 그러나 Servlet의 코드는 보이지 않는다 (POJO(Plain Old Java Object)의 원칙 때문에, 내부적으로는 서블릿 코드가 돈다)
- Spring MVC는 Model2 Architecture와 Front Controller Pattern을 Framework에서 제공
  - Servlet에서 컨트롤러는 act로 분기 후, `request.getParameter`등으로 데이터를 얻고, 서비스를 호출하고, redirect나 forward를 결정한다.
  - act는 doGet, doPost안에 있어야하나, data 호출은 굳이 그 안에 있을 필요가 없다. (클래스로 뺄수 있다.)
  - 이중에 누가하나 비슷한것, act로 분기(if), 어떤 메소드를 호출할것인가?, forward, redirect는 모두 자동화 가능 => framework!, data는 경우에 따라 다르므로 자동 불가(파라미터의 개수, 파라미터의 데이터 타입 등등)
  - Front Controller란 위에서 자동화 할수 있는 부분들을 말한다. => 나머지에만 집중가능
- Spring MVC Framework는 Spring을 기반으로 하고 있기 때문에 Spring이 제공하는 Transaction 처리나
  DI 및 AOP등을 손쉽게 사용.

## Spring MVC 구성요소

- Dispatcher Servlet(= Front Controller, 컨트롤러에게 전달전에 먼저 모든 요청을 받아주는 역할, 즉 컨트롤러 앞에 있다)
  - 모든 클라이언트의 요청을 전달받는다
  - 내가 만든 Controller에게 클라이언트의 요청을 전달하고, Controller가 리턴 한 결과값을 View에게 전달하여 알맞은 응답을 생성
  - 즉, act분기와 forward,redirect를 알아서 해준다.
  - 서블릿 코드가 직접적으로 있지는 않고, 내부적으로 돈다.
- HandlerMapping
  - 클라이언트의 요청 URL을 어떤 Controller가 처리할지를 결정(/../... 을 어느 메소드로 보낼지)
  - URL과 요청 정보를 기준으로 어떤 핸들러 객체(Controller)를 사용할지 결정하는 객체이며, DispatcherServlet은 하나 이상의 핸들러 매핑을 가질 수 있음.
  - 즉 Dispatcher Servlet을 만들때 미리 설정하는것(XML등으로)
- Controller
  - 클라이언트의 요청을 처리한 뒤(= data를 받아서 Service를 호출), Model을 호출하고 그 결과를 DispatcherServlet에 알려준다
  - 앞의 두개는 스프링 컨테이너가 가지고 있고 Framework에서 자동 처리, 이 컨트롤러만 직접 구현하면 된다

## Spring MVC의 구성요소2

- ModelAndView
  - Controller가 처리한 데이터 및 화면에 대한 정보를 보유한 객체.
- ViewResolver
  - Controller가 리턴 한 뷰 이름을 기반으로 Controller의 처리 결과를 보여줄 View를 결정.
  - .jsp파일의 경로가 중복되는것을 ViewResolver에 설정하면 파일 이름만으로 쓸수 있다.
- View
  - Controller의 처리결과를 보여줄 응답화면을 생성.
  - 일반적으론 jsp지만, ajax호출이면 json, 파일이면 파일등 다양하다

## Spring MVC 요청 흐름

![](img/Spring%20MVC%20%EC%9A%94%EC%B2%AD%20%ED%9D%90%EB%A6%84.PNG)

1. Client로 부터 요청이 들어온다.
   - URI와 각종 parameter
2. DispatcherServlet은 이를 HandlerMapping에 보내 어느 컨트롤러로 보내야할지 물어본다.
   - act 분기(if ~ else if)
3. HandlerMapping이 어떤 특정 Controller의 특정 method로 보내야하는지 DispatcherServlet에게 알려준다.
4. DispatcherServlet은 클라이언트의 요청을 해당 Controller의 함수에게 요청을 전달한다.
5. 컨트롤러가 해당 요청을 처리하고 DispatcherServlet에게 ModelView 객체를 리턴한다.
   - request.getParameter 등으로 data 얻기
   - service method 호출
   - request.setAttribute등으로 넘겨줄 데이터 값 설정 (주로 서비스안에서) => Model
   - response page 결정(어느 페이지로 갈껀지) => View(스프링은 .jsp 빼고 보통 이름만 리턴)
6. DispatcherServlet은 ViewResolver에게 어떤 jsp파일로 가야할지 알려달라고 요청
7. ViewResolver는 설정대로 리턴(어떤 폴더경로에 어떤 파일로 가야할지 여기서 5에서 안붙인 .jsp도 붙여서 되돌려준다)
8. DispatcherServlet은 forward(default, 설정바꿔 redirect 가능)로 해당 View로 응답페이지 생성요청을 보냄
9. JSP파일이 생성되어서 Client로 전달

=> HandlerMapping과 ViewResolver는 딱봐도 자동화를 위한 설정을 해줘야함 => XML과 Annotation!
