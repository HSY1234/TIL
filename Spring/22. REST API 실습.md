# REST API 실습

## Spring JSON을 위한 라이브러리 추가

Jackson data binging, JSON library
Jackson library.

- jackson-databind 라이브러리는 객체를 JSON 포맷의 문자열로 변환시켜서 브라우저로 전송한다.
- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind
- jackson-dataformat-xml 라이브러리는 객체를 xml로 브라우저로 전송한다.
- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml

pom.xml에 추가

```xml
<jackson-databind-version>2.13.2.2</jackson-databind-version>
<json-version>20220320</json-version>

<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>${jackson-databind-version}</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.json/json -->
<dependency>
    <groupId>org.json</groupId>
    <artifactId>json</artifactId>
    <version>${json-version}</version>
</dependency>
```

## Responsebody 써서 JSON 한번 해보기 (아직 REST API X+ JackSon 안씀)

```java
// 기본형
@GetMapping("/idcheck")
public String idCheck(@RequestParam("ckid") String checkId) throws Exception {
  logger.debug("아이디 중복 검사: {}",checkId);
  int cnt = memberService.idCheck(checkId);
  return "{idcount:"+cnt+"}";// 이렇게 보내면...
}
// 리턴값만 바꿔보자
@GetMapping("/idcheck")
public @ResponseBody String idCheck(@RequestParam("ckid") String checkId) throws Exception {
  logger.debug("아이디 중복 검사: {}",checkId);
  int cnt = memberService.idCheck(checkId);
  return "{idcount:"+cnt+"}";// 이렇게 보내면...
}
// JSON 객체로 변경
@GetMapping("/idcheck")
	public @ResponseBody String idCheck(@RequestParam("ckid") String checkId) throws Exception {
		logger.debug("아이디 중복 검사: {}",checkId);
		int cnt = memberService.idCheck(checkId);
		JSONObject json = new JSONObject();
		json.put("idcount",cnt);
		return json.toString();
	}

```

위에 처럼 보내면 리턴값인 Stringd의 `{idcount:"+cnt+"}`.jsp파일로 view로 인식해버린다.  
이를 막기위해 리턴타입 앞에 `@ResponseBody`를 넣어준다.(혹은 메소드 위에다)

매번 이렇게 만들기 너무 불편함! => JSON이 라이브러리의 JSONObject 사용!  
`toString`으로 바꿔서 String타입으로 return!

잘보면 json은 Dto로 return하면 알아서 바꿔주지 않을까? (key: value => member변수: 값)  
=> 이렇게 자동으로 객체를 json으로 바꿔주는 라이브러리가 있다. => Jackson!

## JSON 배열 return

```java
@RequestMapping(value = "/user", method = RequestMethod.GET, headers = { "Content-type=application/json" })
//	@ResponseBody ???? 깡 JSON으로 하는 방법
	public @ResponseBody String userList() throws Exception {
		List<MemberDto> list = memberService.listMember();
		System.out.println(list);
		JSONArray arr =new JSONArray();
		for (MemberDto dto: list) {
			JSONObject json = new JSONObject();
			json.put("userid", dto.getUserId());
			json.put("username", dto.getUserName());
			json.put("userpwd", dto.getUserPwd());
			json.put("email", dto.getEmail());
			json.put("joindate", dto.getJoinDate());

			arr.put(json);
		}
		JSONObject obj = new JSONObject();// JSON 배열을 JSON으로 삽입
		obj.put("users", arr);

		return obj.toString();
	}
```

위에서 클래스에 @RestController 달아준 다음, @ResponseBody를 생략하고  
String 리턴값을 그냥 객체 리턴으로 바꿔준다. 그 다음 jackson라이브러리 주석을 풀면  
똑같이 {users: 유저배열}이 리턴된다.

```java
@RequestMapping(value = "/user", method = RequestMethod.GET, headers = { "Content-type=application/json" })
//	@ResponseBody ????
	public List<MemberDto> userList() throws Exception {
//		List<MemberDto> list = memberService.listMember();
//		System.out.println(list);

		return memberService.listMember();
	}
```

=> json 문제는 해결! 문제는 에러코드등을 httpStatus를 넘겨줄수 없다..  
=> ResponseEntity의 등장!
