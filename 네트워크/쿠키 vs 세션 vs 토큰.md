## 인증 VS 인가

인증(Authentication) == 처음 사용자가 로그인을 할때
인가(Authorization) == 한번을 인증 받은 이용자가 로그인이 유지된 상태에서 일을 할수 있는것

즉 JWT는 인가와 관련된 기술이다

매번 ID 패스워드를 보내면 되지않는가? => 로그인은 꽤 무거운 작업이다.
보안을 위한 계산 + DB에서 데이터를 넣고 가져오는것
그리고 매번 보내면 보안상 위험

## 쿠키와 세션

쿠키나 세션을 이용하는 이유는 http가 본질적으로 stateless하기 때문이다.
서버는 이전에 요청이 누구의 것인지 기억하지 않는다. 요청때마다 알려줘야함

쿠키는 로컬에 저장된다.
세션은 서버에 저장된다. 세션은 stateful이다

쿠키는 네이티브 앱에는 존재하지않는다(브라우저에만 있음) => 토큰을 사용해야한다.

쿠키를 통해 서버는 브라우저에 데이터 저장이 가능해진다. 이용자는 http 요청에 쿠키를 담아 보낼수있게된다. 쿠키에는 인증외에 여러 설정도 저장 가능하다.

세션을 사용하는 사이트에서 이용자가 접속하면
기한이 짧은 임시키를 발급하여 브라우저에 보내 사용자의 쿠키에 저장한다.

페이지 접속할때마다 사용자는 http요청에 이 키를 실어서 전송하고, 서버는 이를 통해 이용자를 구분하고 인식하여 알맞은 데이터를 보내준다.

쿠키는 사용자가 변조, 위조등을 할수있으니 지워지거나 가로채여도 문제 없는 정보를 브라우저에 저장
중요한 정보는 세션으로 서버안에 저장된다.

캐시는 가져오는데 비용이 큰 데이터를 중간서버나 사용자 컴퓨터에 저장한는것.

세션을 유지하는 방법은 여러가지가 있다, 서버 메모리 or 하드디스크 or DB 서버에 저장

유저가 로그인되어있는 상태를 세션이라고 부르기도 한다.

메모리에 저장하던건 서버가 에러나 꺼지면 로그인 정보가 다 날아감

## 토큰

토큰은 그저 이상하게 생긴 string이다. 클라이언트에서 토큰을 보내고 서버는 토큰을 확인후 유저를 식별한다.

## 쿠키 세션 인증

유저가 로그인하면 서버는 세션 DB에 유저 ID를 생성하고, 쿠키에 저장시킨다.
서버는 매번 요청에 들어오는 쿠키로 유저를 구별한다. 쿠기의 세션 ID를 세션 DB를 확인후 유저를 일치시킨다.

즉 유저가 늘어날수록 서버에 부담은 점점 커진다. => JWT 토큰의 등장!

## JWT

JWT토큰으로 인증을 하면 세션 DB가 필요없고, 서버는 유저 인증한다고 많은 일을 하지 않아도 된다.
서버는 토큰 데이터를 따로 저장하지 않는다.

XXXX.YYYYY.ZZZZZ 3가지로 구성되어있다.
XXXXX: header 헤더
YYYYY: payload
ZZZZZ: verify signature 서명

payload를 base64로 디코딩해보면 JSON형식으로 여러 정보들이 저장되어 있다.
이 토큰을 누가 누구에게 발급했는지, 이 토큰이 언제까지 유효한지, 서비스가 사용에게 이 토큰을 통해 공개하기 원하는 내용(사용자 닉네임, 서비스상의 레벨, 관리자 여부) => claim이라고 한다.
=> 보안?????? 헤더와 서명으로 해결

헤더도 디코딩해보면 type = JWT 이다. alg(알고리즘) = 3번 서명 값을 만드는데 사용될 알고리즘을 지정한다. HS256등 여러 암호화 방식 중 하나

헤더와 페이로드 그리고 **서버에 감춰놓은 비밀 값** 셋을 암호화 알고리즘에 넣고 돌리면 서명값이 나온다.

암호화 알고리즘은 역으로 푸는게 일단 불가능하기 때문에, 서버만 알고 있는 비밀값을 알아내는것은 불가능하다. 그리고 페이로드 글자 하나만 바뀌어도 값이 서명이 완전히 바뀌게 됨

서버는 요청에 토큰값이 실려 들어오면 1,2번 값을 서버 비밀 키와 함께 돌려서 계산된 결과가 3번과 일치하는지 확인, 정보가 조금이라도 수정하면 해커나 수정한 사용자로 인식

서명값과 계산이 일치하고 유효기간이 지나지 않았다면 서버가 인가!

## JWT 토큰 인증

클라이언트가 유저명 비밀번호를 보냄
유저명 비번이 맞다면, DB에 뭔가를 생성하지 않는다.
유저의 아이디를 사인 알고리즘을 이용해서 사인을 하게된다.
그리고 사인된 정보를 string 형태로 클라이언트에 보낸다.
JWT는 쿠키와 달리 길이 제한이 크지 않다.
이제 다음부터 사인된 정보나 토큰을 서버에 보내면서 요청을 해야한다.
서버는 토큰을 받으면, 토큰이나 사인이 유효한지 체크하고 토큰을 조작했는지 체크한다.
토큰이 유효하면 사용자로 인식한다.
jwt는 암호화 되지 않음, 누구나 열어서 컨텐츠를 볼수있다.(비밀번호 있으면 안됨)

## 세션 VS 토큰

세션은 로그인된 모든 정보를 저장해서, 해당 정보를 이용하면 새로운 기능들을 추가할수있다.
ex) 유저를 쫓아내고 싶으면 삭제만하면됨, 로그인된 모든 디바이스 보여주기, 계정 공유수 제한
세션 DB를 사고, 유지하고 유저가 늘어날수록 서버에 부하가 많이 걸림 => redis를 많이 쓴다.

JWT는 생성된 토큰을 추적하지않음(저장X), 유효한지 아닌지만 판단한다. DB가 따로 필요 X
세션만 가능한 기능을 사용불가, 토큰이 만료전까지는 아무것도 못함

## 세션을 대체하기엔 JWT의 큰 결점

결국 JWT는 사용자의 상태를 기억하고 있지 않기 때문에, 기억 대상의 상태를 제어 할 수가 없다.
토큰이 탈취될 경우, 토큰을 무효화 할 방법도 없다.
JWT만으로 구현한 서비스는 거의 없다.
해결책은 여러종류가 있다. 대칭키 암호화 등등
해결책: 만료시간을 가깝게 잡아서 토큰의 수명을 아주 짧게 준다.
그럼 로그인을 결국 매번하는게 아닌가?
=> 토큰을 두개로 나눈다.
수명이 짧은 access 토큰과 수명이 꽤 긴 refresh 토큰
실제 구현 방법은 매우 많다
예시) access토큰& refresh 토큰을 발급하고 클라이언트에게 보내고 나서 refresh토큰은 DB에 상응값 저장, 손님은 access 토큰의 수명이 다하면 refresh 토큰을 보낸다. 서버는 그걸 DB에 저장된 값과 대조해보고 맞다면 새 access 토큰을 발급.
refresh 토큰이 안전하게 관리된다면 이게 유효하는동안 access토큰이 만료될때마다 새로 로그인하지않고 인가 가능
