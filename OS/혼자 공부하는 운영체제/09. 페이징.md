# 페이징 (paging)

- 외부단편화, 실제 메모리보다 더 큰 프로세스의 문제를 해결하기위해 **가상 메모리** 등장
- 페이징은 세그멘테이션과 함께 가상메모리의 한가지 방법
- 현대 OS는 대부분 페이징 기법을 사용

## 페이징이란?

- 프로세스의 논리 주소 공간을 **페이지** (page)라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임** (Frame) 이라는 페이지와 **동일한 크기**로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이징을 사용하면, 프로세스 단위로 스와핑이 진행되지 않고, 페이지 단위로 프레임이 스와핑 된다
- 페이지 인(page in, = 스왑 인) : 실행에 필요한 페이지가 메모리로 적재
- 페이지 아웃(page out, = 스왑 아웃) : 실행에 필요한 페이지가 메모리에서 보조기억장치로 스왑아웃
- 페이지, 프레임 단위로 쪼갰다 => 외부 단편화 해결
- 프로세스 전체가 메모리에 적재될 필요가 없다! => 큰 프로세스 적재 해결
- 외부단편화 대신 **내부 단편화**(internal fragmentation)가 발생한다
- 내부 단편화는 프로세스의 나눈 페이지 크기가 프레임 크기 보다 작아 메모리 낭비가 발생하는 현상
- 페이지를 작게 설정하면 내부단편화 크기가 줄지만, 프레임테이블이 차지하는 공간이 낭비
- 페이지 크기를 너무 크게하면 페이징하는 의미가 없음

## 페이지 테이블

- 페이지는 메모리에 불연속적으로 배치 되어 있으므로, CPU는 순차적으로 실행 불가
- CPU가 페이지가 어느 프레임에 배치되어있는지 모두 알고 있기가 힘들기 때문
- 이를 해결하기 위해 **페이지 테이블**(page table) 사용
- 페이지 테이블: 물리 주소에 불연속적으로 배치되더라도, 논리주소에는 연속적으로 배치하도록 도와줌, 페이지 -> 프레임 이정표
- 프로세스마다 프로세스 테이블이 존재 각 프로세스의 페이지 테이블은 메모리에 적재되어 있다

  - 프로세스 A
  - 페이지 || 프레임
  - 페이지 0 || 프레임 3
  - 페이지 1 || 프레임 5
  - 페이지 2 || 프레임 1

- CPU내의 **페이지 테이블 베이스 레지스터**(**PTBR**, page table base register)는 각 프로세스 테이블이 적재된 주소를 가리키고 있다.
- 즉 프로세스의 문맥 교환이 일어날때마다 PTBR은 매번 변경된다
- 예를들어 프로세스 A가 실행 될때
  - PTBR 프로세스 A의 페이지테이블의 주소를 저장하고 있고
  - CPU는 해당 페이지 테이블에 접근해 A의 페이지가 저장된 프레임을 알 수 있다.
- 이 방식은 속도 문제가 있음, 메모리 접근이 2번 발생
  - CPU에서 페이지테이블에 접근하는 첫번째 메모리 접근
  - 페이지 테이블에서 알아낸 프레임으로 해당 프레임에 접근하는 두번째 메모리 접근
- 해당 문제를 해결하기 위해 **TLB**(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 CPU곁의 MMU내에 둔다
- TLB는 캐시이기 때문에 페이지 테이블의 일부 내용을 저장함, 참조 지역성에 의거 최근에 사용된 페이지 위주로 저장
- TLB에 논리주소에 대한 페이지 번호가 TLB에 있을 경우 이를 **TLB 히트**(TLB hit)라고 한다
- TLB에 없다면 **TLB 미스**(TLB miss)라고 하고 CPU는 페이지 테이블에 접근하기 위해 메모리에 접근하게 된다.

## 페이징의 주소 변환

- 페이지에 접근하기 위해 필요한 두가지
  - 어떤 페이지 or 프레임에 접근 할지 => 페이지 번호, 프레임 번호(page number)
  - 접근하려는 주소가 그 페이지로 부터 얼마나 떨어져 있는지 => 오프셋, 변위(offset)
  - <페이지번호, 변위> => 페이지 테이블 => <프레임번호, 변위>로 변환이 되어야 한다

## 페이지 테이블 엔트리(PTE, page table entry)

- 페이지 테이블의 각 행의 요소 (db로 치면 속성)
- 유효 비트 (valid bit)
- 보호 비트 (protection bit)
- 참조 비트 (reference bit)
- 수정 비트 (modified bit)

## 유효 비트

- 현재 페이지에 접근 가능 여부(현재 메모리에 적재되어 있는지)
- 메모리에 있다면 1
- 메모리에 없다면 0
- 유효 비트가 0인 페이지로 접근하려고 하면, **페이지 폴트**(page Fault)라는 **예외**(Exception)이 발생

## 페이지 폴트(Page Fault)

- 하드웨어 인터럽트 처리와 유사

1. CPU는 기존 작업 내역을 백업
2. 페이지 폴트 처리 루틴 실행
3. 페이지 처리 루티은 원하는 페이지를 메모리로 가져온뒤, 유효비트를 1로 변경
4. 페이지 폴트를 처리했다면 CPU는 해당 페이지에 접근 가능

## 보호 비트

- 페이지 보호 기능을 위해 존재
- 해당 페이지가 읽고 쓰기가 가능한지, 읽기 전용인지 체크
- 0이면 읽기만 가능 => 코드 영역처럼 읽기 전용인 프로세스의 영역
- 1이면 읽고 쓰기가 모두 가능
- 운영체제가 읽기 전용에 쓰기 시도하면 막는다
- rwx 조합으로도 표현
  - read
  - write
  - execute
- 100 읽기만 가능, 111 읽고 쓰고 실행 가능

## 참조 비트

- CPU가 이 페이지에 적재이후 접근한적 있는지 여부
- 읽거나 쓴 페이지는 1
- 한번도 읽거나 쓴적 없으면 0

## 수정 비트(= dirty bit)

- 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정여부 알려줌
- 1이면 변경된적이 있음
- 0이면 변경된적이 없음(or 읽기만 함)
- 수정비트는 페이지가 메모리에서 사라질때 보조기억장치에 쓰기 작업을 해야할지 여부를 판단하는 용도
- 수정된적 없다면, 스왑 아웃될때 아무런 추가작업 없이 새로 적재된 페이지만 해당 프레임에 쓰면 됨
- 하지만 수정된적이 있다면, 보조기억장치에 해당 페이지를 새로 써야함

# 페이징의 이점 - 쓰기 시 복사

- 쓰기 시 복사(copy on write)
- 프로세스를 생성할때 fork후 exec함
- 프로세스간의 자원을 공유하지 않기 때문에 fork시 통째로 복사해야한다.
- 복사가 일어나면, 다른 물리 메모리 공간에 적재되고, 프로세스 테이블도 따로 생성
- 복사 작업은 프로세스 생성 시간을 늦출뿐만 아니라 불필요한 메모리 낭비
- 쓰기 시 복사에는 자식 프로세스가 페이지 테이블만 만들어지고, 같은 프레임을 가리킨다
- 이러면 메모리 공간을 차지하지 않고 동일한 코드 및 데이터 영역을 카리킴
- 읽기만 할 경우 메모리 절약
- 만약 둘중 쓰기 작업을 페이지에 할 경우, 해당 페이지가 별도의 공간에 복제
- 즉 공유 페이지는 냅두고, 새로 쓴 페이지만 새로운 물리 메모리 할당후 해당 프로세스의 페이지 테이블 프레임 위치 변경

# 계층적 페이징 ( hierarchical paging)

- 프로세스가 커지면 자연히 프로세스 테이블도 커짐, 모든 테이블 엔트리를 메모리에 두는것은 큰 낭비
- **계층적 페이징**의 등장
- 페이지 테이블을 여러단계 두는 방식, **다단계 페이지 테이블**(multilevel page table)기법이라고도 함
- 페이지 테이블을 계층적으로 유지하면서, 모든 페이지 테이블이 항상 메모리에 있을 필요가 없다(가장 밖의 Outer table 제외)
- 계층적 페이징에서 페이지 접근 방법
  - 바깥 페이지 번호, 안쪽 페이지 번호, 오프셋 형태로 저장
  - 바깥 페이지 번호에 접근해서, 바깥 페이지 테이블에 접근
  - 바깥 페이지 테이블에서 안쪽 페이지 테이블의 번호를 찾아서 접근
  - 안쪽 페이지 테이블에서 프레임번호를 찾고 오프셋을 더해서 물리 주소 얻기
- 계층적 페이징은 여러계층이 가능 2,3,4
- 계층이 늘어날수록 페이지 폴트가 발생했을때 메모리 참조 횟수가 증가하기 떄문에 너무 깊은건 좋지 않다
