# 동기화

- 프로세스들은 공동의 목적을 수행하기위해 협력하기도 함
- 프로세스들은 실행 순서와 자원의 일관성을 보장하기 위해 반드시 **동기화(synchronization)**해야함
- 프로세스 동기화란 프로세스사이의 수행 시기를 맞추는 것을 의미
  - 실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기
    - 파일 읽기 프로세스와 파일 쓰기 프로세스는 쓰기가 먼저
  - 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기
    - 계좌 잔액을 읽고 2만원 추가, 5만원 추가를 각각 진행하면 7만원 추기
    - 만약 동시 접근이면 둘다 원금을 읽고 각각 덧셈까지는 끝났는데 쓰기가 2번 이루어져 12 or 15만원 이 될수 있다
- 두 개념은 스레드에도 똑같이 적용됨

# 생산자와 소비자 문제

- 물건을 계속 생산하는 프로세스
- 물건을 계속 소비하는 프로세스
- 생산자와 소비자는 총합이라는 데이터를 공유
- 시작 값 100 생산자와 소비자를 n번씩 동시에 실행하면 결과는 100? => 전혀 다른값이 나옴
- 프로세스가 쓰는 작업이 끝나기 전에 읽는 경우가 매우 빈번하게 발생해서 결과 예측 불가

# 공유자원과 임계구역

- 프로세스가 동시에 접근 할수 있는 자원을 **공유 자원**(shared resource)라고 한다
- 전역 변수, 파일, 입출력장치, 보조기억장치 등 모두 가능
- 공유자원중 두개 이상 프로세스가 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 **임계 구역**(critical section)이라고 한다
- 두개 이상의 프로세스가 임계 구역에 진입하려고 하면, 하나는 대기해야 함
- 한 프로세스가 임계구역에서 작업을 마무리하면, 다음 프로세스가 임계구역에 진입해야 한다
- 여러 프로세스가 동시다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우를 **레이스 컨디션**(race condition)이라고 한다
- 레이스 컨디션이 발생하면 데이터의 일관성이 깨지는 문제가 발생한다.
- 레이스 컨디션이 발생하는 이유
  - 고급 언어가 저급 언어로 변환되었을 때
  - 고급 언어 한줄이 저급 언어 여러줄이 되고, 고급 언어 한줄이 실행되는 동안 문맥 교환이 일어날수 있기 때문

# 임계 구역 문제 해결을 위한 3가지 원칙

- 상호 배제(mutual exclusion) : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 진입 불가
- 진행(progress) : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈수 있어야 한다
- 유한 대기(bounded waiting) : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다(임계 구역에 들어오기 위해 무한정 대기해서는 안됨)

# 동기화 기법

- 뮤텍스 락
- 세마포
- 모니터

# 뮤텍스 락

- 화장실의 손님이 줄을 서있는 것을 상상 손님은 프로세스, 화장실은 임계구역
- 사용중일때 다른 프로세스가 접근 못하게 **락**을 걸면 된다.
- 이를 **뮤텍스 락**(Mutex lock, Mutual EXclusion lock, 상호배제 락)이라고 합니다
- 동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 만드는 도구
- 상호배제를 위한 동기화 도구
- 구현 방식
  - 자물쇠 역할: 프로세스들이 공유할수 있는 전역 변수 lock
  - 임계 구역을 잠구는 역할: acquire 함수
  - 임계 구역의 잠금을 해제하는 역할: release 함수
- 프로세스는
  - 락을 획득할수 없다면 기다리고
  - 락을 획득할수 있다면 임계구역을 잠구고 작업 진행
  - 임계 구역에서 빠져 나올땐 잠금을 해제

## acquire 함수

- 임계구역 진입전에 호출
- 임계구역이 잠겨 있다면 임계구역이 잠겨있을때까지 반복적으로 확인하고(while 등으로)
- 열려있다면 잠구는 함수(lock을 true)
- 쉴새 없이 문이 잠겨있는지 확인하는 대기 방식을 **바쁜 대기(busy wait)**라고 한다
- C/C++, python등은 acquire, release 함수를 직접 구현하지 않고, 뮤텍스 락 기능을 제공, 훨씬 정교하게 구현되어있다

## release 함수

- 임계구역에서 작업이 끝나고 호출
- 현재 잠긴 임계 구역을 열어주는 함수(true -> false)

# 세마포(semaphore)

- 세마포는 뮤텍스 락과 비슷하지만 좀 더 일반화된 방식의 동기화 도구
- 이진 세마포(binary semaphore)와 카운팅 세마포(counting semaphore)가 있음
- 공유자원이 여러개일때도 적용가능
- 깃발이라는 어원에서 유래, 철도 신호기 내려가 있을때는 기차가 멈추고, 올라가 있을땐 통과
- 구성요소
  - 전역변수 S: 임계 구역에 진입할 수 있는 프로세스의 개수를 나나태는 변수
  - wait 함수: 임계 구역에 들어가도 좋은지, 기다려야하는지 알려주는 함수
  - signal 함수: 임계 구역 앞에서 기다리는 프로세스에 이제 가도 좋다는 신호를 주는 함수

```
wait()
// 임계 구역
signal()

wait() {
  while(S<=0) // 접근가능한 프로세스가 0이하면 못 지나가게

  S--;
}

signal(){
  S++;
}
```

- 여전히 busy wait가 발생해서 CPU 자원이 낭비된다
- 세마포어는 wait함수에서 프로세스를 대기 상태로 만들고, 그 프로세스의 PCB(본인)를 세마포를 위한 대기 큐에 넣는다
- 다른 프로세스가 임계 구역에서 작업이 끝나고 signal 함수를 호출하면, 대기중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경하고 준비 큐로 옮겨줌

```
wait() {
  S--;
  if(S<0){
    이 프로세스를 큐에 집어넣기;
    sleep();
  }
}

signal(){
  S++;
  if(s<=0){
    큐에서 프로세스 P 꺼내기;
    wakeup(p);
  }
}
```

- 이렇게 하면 상호배제는 성공이지만, 프로세스의 접근 실행 순서 제어가 안된다
- 변수값을 0으로 하고 먼저 실행할 프로세스는 wait() 없이 마지막에 signal()만, 나중에 들어올 프로세스는 wait()만 추가 => wait()는 무조건 큐에 들어가므로 signal()신호가 오면 실행 시작

# 모니터(monitor)

- 세마포는 휼륭한 도구지만, 사용하기 조금 불편, 매번 wait signal 추가는 실수유발 & 힘든 행동
- 이를 위해 **모니터** 기법 등장
- 모니터는 공유자원에 접근하기 위한 인터페이스(통로)를 묶어서 관리, 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근가능
- 모니터를 통해 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 순서대로 하나씩 공유자원을 활용하게 만든다
- 모니터는 공유자원을 다루는 인터페이스에 접근하기 위한 큐를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 **상호 배제**를 만족시킨다
- 세마포와 마찬가지로 **실행 순서 제어**를 위한 동기화도 제공
- 특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해 모니터는 **조건 변수**(conditional vairiable) 사용
- 조건변수로 wait와 signal 연산을 수행하여 프로세스나 스레드의 실행 순서를 제어
- 조건변수는 모니터와 별개의 개념이다(분리됨)
- 즉 모니터의 상호배제를 위한 큐(모니터 진입 용), wait가 호출되어 실행이 중단된 프로세스들이 삽입되는 큐(조건변수 큐)가 따로 존재
- 상호배제를 위한 큐는 모니터에 하나의 프로세스만 들어가기 위해 존재하는 큐이고, 조건 변수 큐는 이미 진입한 프로세스의 실행 조건이 만족될때 까지 잠시 실행이 중단되어 기다리는 장소이다.
- 예시

  - 모니터에 진입한 프로세스가 x.wait()를 하면 조건변수 x 큐에 삽입
  - 실행을 마친 프로세스가 x.signal()을 호출하면 x 큐에서 깨어나 다시 모니터에 진입

- 특정 프로세스가 아직 실행될 조건이 충족되 않았을때 wait로 실행 중단
- 특정 프로세스가 실행될 조건이 충족되었을때는 signal을 통해 실행 재개
