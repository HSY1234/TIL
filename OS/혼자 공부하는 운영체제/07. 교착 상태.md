# 교착상태 (Deadlock)

- 두 개 이상의 프로세스가 각자 가지고 있는 자원을 기다리면 어떤 프로세스도 더 이상 진행 불가

## 식사하는 철학자 문제 (dining philosophers problem)

- 둥근 원탁에 철학자 5명이 앉아 있다. 이들 앞에는 식사와 그 사이에 포크가 한개씩 존재
- 규칙 순서
  - 생각을 계속하다가 왼쪽 포크가 사용가능하면 집어든다
  - 생각을 계속하다가 오른쪽 포크가 사용가능하면 집어든다
  - 왼쪽과 오른쪽 포크를 모두 집어들면 정해진 시간동안 식사를 한다
  - 식사 시간이 끝나면 오른쪽 포크를 내려놓는다
  - 오른쪽 포크를 내려 놓은 뒤 왼쪽 포크를 내려놓는다
  - 1~5 반복
  - 철학자는 식사를 마칠수 있을까? 운이 좋다면 가능
- 철학자가 동시에 포크를 집어 식사를 하면 어떤 철학자도 식사를 할수없고, 영원히 생각만함(오른쪽 포크가 와야하는데 아무도 놓지않으니까, 양손에 포크를 들수 없으니 아무도 포크를 놓지도 않음)

## 다른 예시

여기 사람1, 사람2 와 종이1, 종이2가 있다. 두 종이에는 숫자가 적혀 있는데, 여기서 사람 두명이 종이1의 숫자에 종이2의 숫자를 더한 것을 계산한다고 생각해 보자. 사람 둘은 접촉할 수 없고, 종이를 교환하지도 못한다.

만약 운이 좋다면,

- 사람1이 종이 1, 2를 모두 가져간다.
- 사람2가 종이가 없는 것을 확인하고 기다린다.
- 사람1이 계산을 마치고 종이 1, 2를 돌려놓는다.
- 사람2가 종이 1, 2를 모두 가져간다.
- 사람2가 계산을 마치고 종이 1, 2를 돌려놓는다.
- 두 명 모두 작업을 정상적으로 종료한다.
  이런 방식으로 일이 진행될 것이다.

하지만 일이 꼬일 수도 있다.

- 사람1이 종이1을 가져간다.
- 사람2가 종이2를 가져간다.
- 사람1이 종이2가 없는 것을 확인하고 기다린다.
- 사람2가 종이1이 없는 것을 확인하고 기다린다.

이런 경우 서로 기다리느라 명령의 진행이 멈추머, 같은 상태가 계속 지속되게 된다. 이러한 교착 상태를 데드락이라 한다.

## 동기화 해결 기법 - 뮤텍스락에서

- 동시에 프로세스 A는 락 1번을 잠그고, 프로세스 B는 락 2번을 잠금
- 이제 프로세스 A는 2번자원이 필요해 락을 확인 => 잠겨있음 => 대기
- 프로세스 B는 1번자원이 필요해 락을 확인 => 잠겨있음 => 대기
- 서로 무한 대기

## 자원 할당 그래프(resource-allocation graph)

# 교착 상태의 발생 조건

- 상호배제
- 점유와 대기
- 비선점
- 원형 대기

## 상호배제(mutual exclusion)

- 하나의 자원은 하나의 프로세스만 사용가능하다
- 누군가 사용하고 있다면 다른 프로세스는 해당 자원을 사용할수없다

## 점유와 대기(hold and wait)

- 자원을 할당 받은 상태에서 다른 자원을 기다리는 상태
- 한 자원을 가진채로 다른 자원을 대기한다

## 비선점(nonpreemptive)

- 자원을 비선점하고 있다.(중간에 강제로 뺏는것이 불가능)

## 원형 대기(circular wait)

- 프로세스들과 프로세스가 요청 및 할당받은 자원이 원의 형태를 이룬다
- 이러한 원형으로 대기하는것을 **원형 대기**라고 한다
- 자원 할당 그래프가 원의 형태가 되면 교착 상태가 발생할수 있음( 원형이라고 무조건 교착상태 발생은 X)

# 교착상태 해결법

- 예방
- 회피
- 검출 & 회복

# 교착상태 예방(prevention)

- 교착상태의 발생 조건 4가지중 하나라도 만족시키지 않으면 됨
- 원천적으로 교착 상태를 방지할수 있지만, 여러 부작용이 있어 현실적이지 않음

## 상호배제 제거

- 자원을 공유하여 사용할수 있다
- 한 자원을 공유하면 임계구역이 무너져 결과가 이상해짐
- 상호배제를 없애기는 어렵기 때문에 현실적으로 무리

## 점유와 대기 제거

- 점유한 상태에서 다른 자원을 기다리지 못하게 만들면된다
- 전부 할당 하거나 아예 할당하지 않음(all or nothing)
- 필요한 자원을 전부 할당하지 못하면 자원을 모두 반납
- 자원 활용률이 낮아짐
- 많은 자원을 동시에 쓰는 프로세스는 불리해짐 기아현상 가능성

## 비선점 제거

- 다른 프로세스의 자원을 뺏어올수 있음
- 일부 자원에는 효과적, 대표적으로 CPU는 프로세스가 선점할수 있는 대표적인 자원
- 프린터 같은 경우는 선점이 의미가 없음, 특정 자원만 가능한 범용성이 매우 떨어지는 방법

## 원형대기 조건 제거

- 모든 자원에 번호를 붙이고 오름차순으로 자원을 할당 => 원형 발생 원척적으로 불가
  - 자원을 보유하고 있다면 더 큰 번호를 가진 자원만 할당 가능, 작은건 불가
- 컴퓨터의 모든 시스템내의 자원들에게 번호를 붙이는 일은 거의 불가능
- 붙이는 번호에 따라 자원 활용률 변동

# 교착 상태 회피(avoidance)

- 교착 상태가 발생하지 않을 정도로만 조심 조심 자원을 할당하는 방식
- 교착 상태의 발생 원인을 한정된 자원의 무분별한 할당으로 발생했다고 생각함
- ex 철학자 10명에 포크가 100개라면?
- **안전상태**(safe state): 교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될수 있는 상태
- **불안전 상태**(unsafe state) : 교착상태가 발생할수도 있는 상황
- **안전 순서열**(safe sequence) : 교착상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
- 즉 안전 상태는 안전 순서열대로 프로세스들에 자원을 배분한 상태
- 불안전 상태는 안전 순서열이 없는 상황
- 문제점: 프로세스가 자기 사용할 자원의 내용을 모두 알고 미리 선언해야함
- 문제점2: 시스템 자원수가 고정적이어야함
- 문제점3: 자원 낭비 발생

# 검출

- 교착상태를 예방이나 회피가 불가능함을 인정하고 사후에 조치하는 방법(회복과 세트)
- 주기적으로 교착상태 발생 여부를 체크
- 검출방법 의 대표적인 예로 타임아웃이 있다(프로세스가 일정시간이 지났는데도 종료가 안됨)

# 회복

- 선점을 통한 회복 : 교착 상태가 해결 될때 까지 한 프로세스씩 자원을 몰아줌
- 프로세스 강제 종료를 통한 회복:
  - 한꺼번에 모두 종료:
  - 교차를 일으킨 프로세스들중 우선순위가 낮은것 하나씩 종료:
- 타조 알고리즘: 교착 상태를 아예 무시
