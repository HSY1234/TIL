# CPU 스케줄링

- 모든 프로세스는 CPU를 쓰고 싶어한다
- 운영체제는 프로세스들에게 공정하고 합리적으로 CPU 자원을 분배해야하고, 이를 **CPU 스케줄링**이라 한다
- 운영체제의 가장 핵심 기능 중 하나

# 프로세스 우선순위 (prioirty)

- 프로세서마다 우선순위가 다르기 때문에 요청순서대로 순서를 지정하는건 좋은 방법이 아님
- 대표적으로 입출력 작업은 우선순위가 높은 편
- 대부분의 프로세스는 CPU와 입출력장치를 모두 이용한다.
  - 즉 프로세스 대부분은 실행상태와 대기상태(waiting)를 왔다갔다 함
  - 워드 프로세서는 CPU를 통해 명령어를 사용하고, 입력내용을 저장하고, 명령어를 실행, 화면에 출력 반복
  - 입출력 집중 프로세스(I/O bound process) : 비디오, 디스크 백업
  - CPU 집중 프로세스(CPU bound process) : 수학, 컴파일, 그래픽 처리
  - 입출력은 대기, CPU는 실행 상태에 더 오래 머무른다
  - 즉 성향이 다른 두 프로세스가 같은 빈도로 CPU를 사용하는건 바람직하지 않다
- CPU 버스트(CPU burst) : CPU를 이용하는 작업
- 입출력 버스트(I/O burst) : 입출력 장치를 기다리는 작업
- 두 유형이 동시에 온다면, 입출력을 먼저 하는게 좋다 => 입출력을 끊임없이 동작시키고 대기, CPU는 CPU집중 프로세스에 집중
- 이런 다양한 경우를 위해 운영체제는 프로세스에 **우선순위**를 부여한다
- 우선순위는 PCB에 명시되어 있고, 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행한다

## 스케줄링 큐

- PCB에 우선순위가 적혀 있다고 하지만, 매번 모든 PCB를 찾는건 낭비
- CPU를 쓰고 싶은 프로세스, 메모리에 적재되고 싶은 프로세스, 특정 입출력 장치를 사용하고 싶은 프로세스 등등 사용하고 싶은 프로세스들을 각각 모두 줄세운다
- 이를 **스케줄링 큐**라고 한다 (다만 자료구조 큐 FIFO는 아니다)
- **준비 큐**(ready queue) : CPU를 이용하고 싶은 프로세스들이 서는 줄
- **대기 큐**(waiting queue) : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
- PCB들은 준비 큐에 마지막에 삽입되어 차례를 기다리다, 우선순위가 높은 프로세스를 먼저 실행
- 대기 큐는 장치마다 큐가 있고, 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기다림
- 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 완료된 PCB를 찾고, PCB를 준비 상태로 바꾸고 대기큐에서 제거후 준비큐에 삽입

# 선점과 비선점(preemptive scheduling, non-preemptive scheduling)

- CPU가 너무 급한 프로세스가 지금 당장 쓰기를 요청한다면?
- 지금 CPU 사용중인 프로세스한테 빼앗아 할당해주거나 => 선점형 스케줄링(preemptive scheduling)
- 지금 CPU 사용중인 프로세스의 작업이 끝날때까지만 기다렸다가 할당 => 비선점형 스케줄링(non- preemptive scheduling)
- 현대 대부분의 운영체제는 선점형 스케줄링 방식 사용
  - 급한 프로세스가 언제든 끼어들어 사용할 수 있어 자원 독점을 막고 골고루 자원 분배
  - 문맥 교환과정에 오버헤드가 상대적으로 더 많이 발생

# CPU 스케줄링 알고리즘

- **CPU 스케줄링 알고리즘**은 매우 다양하고 운영체제마다 다름 (외우지말고 이해만 하면 됨)
- 선입 선처리 스케줄링
- 최단 작업 우선 스케줄링
- 라운드 로빈 스케줄링
- 최소 잔여시간 우선 스케줄링
- 우선순위 스케줄링
- 다단계 큐 스케줄링
- 다단계 피드백 큐 스케줄링

- 비선점형
  - 선입선처리
  - 최단 작업 우선 스케줄링
- 선점형
  - 라운드 로빈
  - 최소 잔여 시간 우선

## 선입선처리 스케줄링(FCFS 스케줄링, First Come First Served Scheduling)

- 준비 큐에 삽입된 순서대로 프로세스를 처리하는 **비선점형 스케줄링**
- 앞에 사용시간이 긴 프로세스가 있으면, 사용시간이 짧은 프로세스는 잠깐의 시간이 필요함에도 오래 기다림
- 이런 현상을 **호위 효과**(convoy effect)라고 한다

## 최단 작업 우선 스케줄링(SJF 스케줄링, Short Job First Scheduling)

- 호위 효과를 방지하기 위한 아이디어
- 가장 CPU 사용이 짧은 프로세스 먼저 실행
- 기본적으로는 **비선점형** 이지만 선점형으로도 구현 가능
- => 선점형으로 구현하면 SRT 스케줄링이다
- 결국 너무 긴 작업은 계속 순위가 뒤로 밀리는 **기아 현상** 발생 => 에이징 기법으로 해결

## 라운드 로빈 스케줄링(RR, round robin scheduling)

- FCFS 스케줄링에 **타임 슬라이스**라는 개념이 추가된 스케줄링 방식
- 타임 슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 정해진 타임 슬라이스만 이용하고 넘겨주기 떄문에 **선점형 스케줄링**
- 큐에 삽입된 프로세스들은 삽입된 순서대로 CPU를 이용하고 완료되지 않았다면 **문맥교환**과 함께 다시 큐의 맨뒤로
- 라운드 로빈의 핵심은 타임 슬라이스의 크기!
  - 너무 크면 FCFS랑 다를바 없는 스케줄링이고 => 호위효과 발생
  - 너무 작으면 문맥교환에 비용이 커져서 CPU가 프로세스 처리가 아닌 전환에 더 많은 자원을 씀

## 최소 잔여 시간 우선 스케줄링(SRT 스케줄링, Shortest Remaining Time Scheduling)

- SJF의 선점형 버전
- SJF와 RR을 섞은 방식이다
- 타임슬라이스를 돌아가며 CPU를 사용하고, 남은 작업 시간이 가장 적은 프로세스 선택
- 여전히 기아상태 발생, 타임슬라이스를 바꿀때마다 남은 작업시간을 계속 따로 계산해줘야함

## 우선순위 스케줄링(priority 스케줄링)

- 프로세스들에게 우선순위를 부여하고 가장 높은 우선순위를 가진 프로세스부터 실행
- 우선순위가 같다면 선입 선처리로
- 크게 보면 위에 있는 모든 스케줄링도 우선순위(먼저 온순서, 짧은 시간)
- **기아현상(starvation)**: 우선순위 높은 프로세스에 의해 우선순위 낮은 프로세스가 계속 뒤로 밀려 실행되지 못하는 현상
- **에이징**(aging): 오랫동안 실행되지 못한 프로세스의 우선순위를 점차 높이는 방식

## 다단계 큐 스케줄링(multilevel queue scheduling)

- 우선순위 스케줄링이 발전한 단계
- 우선순위 별로 준비 큐를 여러개 사용
- 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리하고, 만약 비었다면 다음 우선순위가 높은 준비 큐를 처리
- 큐별로 타임 슬라이스를 여러개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할수도 있다
- 그러나 큐 사이 이동이 불가능해 기아 현상이 여전히 발생

## 다단계 피드백 큐 스케줄링(multilevel feedback queue scheduling)

- 다단계 피드백 큐 스케줄링이 발전,보완한 형태
- 다단계 큐 스케줄링은 프로세스들이 큐 사이를 이동하는것이 불가능
- 실행중인 프로세스가 타임슬라이스동안 실행하고 완료가 되지 않았다면, 현재가 아닌 그 다음 우선순위 큐에 삽입됨
- CPU 실행이 긴 프로세스(타임슬라이스가 여러번)이면 우선순위 큐 레벨이 점점 내려감
- CPU 집중 프로세스들은 자연스럽게 우선순위가 낮아지고, CPU를 적게 사용하는 입출력 집중 프로세스는 우선순위가 높은 큐에서 실행됨
- 물론 너무 우선순위가 낮은 큐까지 내려가면 기아현상이 발생하므로 에이징 기법(높은 우선순위 큐로 이동시켜줌)을 적용해야한다.
- 가장 일반적인 CPU 스케줄링 알고리즘
