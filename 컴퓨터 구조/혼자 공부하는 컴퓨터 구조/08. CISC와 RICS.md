# CISC & RISC

- 명령어 파이프라이닝과 슈퍼스칼라 기법을 사용하기 위해선 CPU의 명령어가 파이프라이닝에 최적화 되어야함
- 즉 CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝에 최적화 되어야함

# 명령어 집합 구조(ISA, Instruction set Architecture)

- 명령어 집합(instruction set)이라고도 함
- 제조사나 CPU 목적에 따라 CPU의 설계, 규격, 기능은 모두 다르기 때문에 명령어도 모두 다르다
- CPU가 이해할수 있는 명령어들의 모음, CPU 제조사에서 보통 배포
- 예를들어
  - 인텔 노트북 : x86(32bit) or x86-64(64비트용 x86) ISA를 이해
  - 애플 아이폰 : ARM ISA를 이해
  - 서로 다른 CPU는 한쪽에서 돌아가는 실행파일을 그대로 실행할수 없다
- ISA가 다르다는 말은, 같은 소스 코드라도 CPU가 이해할 수 있는 명령어인 어셈블리어가 달라진다는 뜻
- ISA가 같아도 컴파일러나 컴파일러의 버전이 달라도 또 어셈블리어가 달라진다
- 명령어 병렬 처리 기법들은 ISA에 따라 유리 불리가 존재

# CISC (Complex Instruction Set Computer)

- 복잡한 명령어 집합을 활용 하는 컴퓨터
- x86, x86-64가 대표적으로 CISC기반의 ISA
- **가변길이 명령어**를 사용
- 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 매우 다양함
- 장점: 상대적으로 명령어 수가 적음 => 메모리를 최대한 아끼며 개발 가능
- 단점: 명령어가 복잡하고 다양해 명령어의 크기와 실행되기까지 시간이 일정하지 않음 => 복잡한 명령어는 여러 클럭이 필요
  - 이러한 단점이 파이프라인 구현에 큰 문제가 됨(파이프라이닝은 단계별로 소요시간이 가급적 동일해야하므로)
  - 대다수의 복잡한 명령어는 생각보다 사용 빈도가 낮음, 쓰던 명령어만 계속 씀

# RISC (Reduced Instructions Set Computer)

- 빠른 명령어 처리를 위해서는 파이프라이닝을 활용해야함, 파이프라이닝을 위해 명령어 길이와 수행시간은 짧고 규격화되어 있어야함
- 어차피 자주 쓰이는 명령어만 계속 사용되므로, 복잡한 기능을 지원하는 명령어보단 자주 쓰이는 기본 명령어들을 작고 빠르게 만드는것이 중요

- **고정 길이 명령어**
- 명령어 종류가 적다
- 짧고 규격화된 명령어(되도록 1클록 내외로 실행되는)
- 예를 들어
  - RISC는 메모리에 접근하는 명령어가 load, store 두개로 제한됨
  - 따라서 RISC를 load-store구조라고 부르기도 함
- 메모리 접근을 단순화, 최소화한 대신 레지스터를 적극 활용
- CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많음
- 대신 CISC보다 명령어가 많다

# CISC VS RISC

|             CISC             |              RISC               |
| :--------------------------: | :-----------------------------: |
|    복잡하고 다양한 명령어    |      단순하고 적은 명령어       |
|          가변 길이           |            고정 길이            |
|    다양한 주소 지정 방식     |       적은 주소 지정 방식       |
|  프로그램의 명령어수가 적음  |   프로그램의 명령어수가 많음    |
| 여러 클럭에 걸쳐 명령어 수행 | 가급적 1클럭 내외로 명령어 수행 |
|    파이프라이닝이 어려움     |       파이프라이닝이 쉬움       |
