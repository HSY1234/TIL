# 명령어 병렬 처리 기법(ILP, Instruction-Level Parallelism)

- 빠른 CPU를 만들려면 높은 클럭속도, 멀티코어, 멀티스레드를 지원하는 CPU를 쓰는것이 중요
- 그러나 CPU가 쉬지않고 돌아가게 하는것도 중요
- 명령어 병렬 처리 기법(ILP) : 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않게 하는 기법
  - 명령어 파이프라인
  - 슈퍼 스칼라
  - 비순차적 명령어 처리
  - 등등

# 명령어 파이프라인

- 단계가 겹치지만 않으면 CPU가 각 단계를 따로 따로 동시에 실행할 수 있다는 생각에서 출발
- CPU는 한 명령어를 인출하면서, 다른 명령어를 해석하고, 해석하는 동안 또 다른 명령어는 실행하고, 실행하는 동안 또 다른 명령어의 연산 결과를 저장할수 있다.
- 이런 과정이 분업을 통해 공장 생산 라인에서 물건을 완성하는 것과 비슷해다고 해서
- **명령어 파이프라인(Instruction pipline)**에 넣고 진행하는 **명령어 파이프라이닝(Instruction pipeline)**이라고 한다

## 명령어의 전통적인 4단계 파이프라인

- 명령어 인출 (Instruction FETCH)
- 명령어 해석 (Instruction Decode)
- 명령어 실행 (Execute Instruction)
- 결과 저장 (Write Back)

- 전공서에 따라 인출-> 실행,  
  인출 -> 해석 -> 실행 -> 메모리 접근 -> 결과 저장 등 다양한 방식으로 나눔

## 파이프라인 위험(pipeline hazard)

파이프라이닝은 이론적으로 파이프라인 단계배(4배~) 만큼 빨라질수 있지만, 특정 상황에서는 성능 향상에 실패하는 경우가 발생, 이를 파이프라인 위험이라고 한다

- 데이터 위험
- 제어 위험
- 구조적 위험

## 데이터 위험(data hazard)

- 명령어 간의 데이터 의존성에 의해 발생
- 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행 가능하기 때문에, 모든 명령어를 동시에 처리할수가 없다.
- 예) R1 레지스터에 R2+R3값을 저장, R4에 R1+R5를 저장이면 첫 명령어가 끝나야 다음이 시작 가능

## 제어 위험(control hazard)

- 주로 분기 등으로 인해 **프로그램 카운터의 갑작스러운 변화**로 발생
- 기본적으로 프로그램은 다음 명령어를 수행하지만 흐름이 바뀌어 명령어가 실행되면 미리 처리중이던 명령어들은 아무 쓸모가 없어짐

## 구조적 위험(structural hazard)

- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 같은 CPU 부품을 사용할때 발생
- 자원 위험(resource hazard)라고도 함

## 분기 예측(Branch Prediction)

- 데이터 위험과 제어 위험를 해결하기 위해 사용하는 기술중 하나

파이프라인이 등장하면서 CPU는 수행이 채 끝나지도 않은 명령어의 결과를 사용해야 하는 일이 종종 있게 되었다. 특히 분기 명령어(branch instruction)의 경우 그 조건을 평가하는 데 필요한 값이 아직 계산되고 있다면, 어떤 명령어를 다음에 수행해야 할지 명령어를 가져오는(fetch) 단계에서 아직 판단할 수 없으므로 필요한 값이 다 계산될 때까지 기다리는(stall) 수밖에 없었는데, 이는 CPU의 성능을 크게 떨어뜨리는 요인이 되었다. 특히 이는 파이프라인이 깊어지면서 더 심해지는 문제였다. 그래서 필요한 값을 기다리지 않고 어떻게 분기할지 예측하여 파이프라인이 끊기지 않고 계속 수행되도록 하는 기법들이 여럿 등장하게 되었다. 이에 따라 CPU는 명령어를 가져오는 단계에서 분기 명령어의 조건을 아직 평가할 수 없다면 어떻게 분기할지 예측하여 그대로 다음 명령어를 수행하고, 나중에 조건을 평가할 수 있을 때 앞서의 예측이 틀렸다면 예측하여 수행된 명령어들을 취소하고 올바른 분기의 명령어를 다시 수행하게 된다.

높은 정확성의 분기 예측이 가능한 것은 프로그램 안에 있는 각 분기 명령어가 대부분 분기되거나(taken) 분기되지 않거나(not taken)의 둘 중 한 쪽 경우를 훨씬 많이 이용하는 경향성이 있기 때문이다. 예컨대 분기 명령어 하나로만 구성된 간단한 do-while 루프를 생각해 보자. 보통 루프를 계속 수행하는 경우가 루프를 벗어나는 경우보다 훨씬 많으므로, 돌아가는 분기를 타는(taken) 쪽으로 예측하면 정확성이 높을 것이다.

- 종류
  - 정적 분기 예측
  - 동적 분기 예측
  - 분기 예측 버퍼
  - 연관 분기 예측
  - 등등

# 슈퍼스칼라

- 슈퍼스칼라: CPU 내부에 여러개의 명령어 파이프라인을 포함한 구조
- 파이프라이닝은 단일 파이프라인으로 구현이 가능하지만, 오늘날 대부분은 CPU에 여러개의 파이프라인 이용
- 파이프라인 = 공장 생산 라인 1개, 슈퍼스칼라 = 공장에 생산 라인 여러개
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서, 슈퍼스칼라 CPU라고 함
- 멀티스레드 프로세서는 한 번에 여러 며ㅏㅇ령어를 인출하고, 해석하고, 실행해야하므로 슈퍼스칼라 구조를 사용
- 여러 파이프라인을 쓴다는 의미는 곧 파이프라인 위험도 증가한다는 뜻이므로, 설계가 훨씬 까다롭다

# 비순차적 명령어 처리(OoOE: Out-of-Order execution)

- 명령어들을 순차적으로 실행하지 않는 기법
- 명령어 파이프라이닝, 슈퍼스칼라는 모두 순차적 처리를 가정하고 처리하는 기술
- 순차적으로 실행하면 파이프라인 위험이 발생하지만, 더 뒤에 파이프라이닝을해도 위험이 발생하지 않는 데이터 의존성 없는 명령어들도 존재
- 이런 명령어를 데이터 의존성 있는 명령어보다 먼저 넣어서 파이프라이닝을 멈추지 않는 기법
- 물론 아무 명령어나 순서를 바꿀순 없다, CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어는 언떤게 있는지 판단할수 있어야함
