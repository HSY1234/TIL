# 명령어 사이클

- CPU가 하나의 명령어를 처리하는 과정에는 어떤 정해진 흐름이 있고, CPU는 그 흐름을 반복하며 명령어를 처리
- 이렇게 하나의 명령어를 처리하는 일련의 과정을 **명령어 사이클**이라 함
- 그러나 사이클 중간에 흐름이 끊어지는 경우도 존재한다. 이를 **인터럽트**라고 한다.

## 명령어 사이클(instruction cycle)

- 인출 사이클(Fetch cycle): 명령어를 메모리에서 CPU로 가져온다
- 실행 사이클(Execution cycle): CPU에서 명령어를 실행한다
  - 제어장치가 명령어 레지스터에 담긴 값을 해석, 제어 신호를 발생
- 프로그램을 이루는 많은 명령어들은 인출과 실행의 반복, 즉 CPU는 프로그램 속 명령어를 가져오고 실행하고, 또 가져오고 실행하고 반복
- 그러나 어떤 명령어는 CPU에 가져와도 바로 실행 불가 (특히 데이터가 메모리에 있는 경우)
  - 간접 주소 지정 방식의 경우 오퍼랜드 필드에 유효주소가 있으므로 다시 메모리로 가야함
- 간접 사이클(indirect memory): 명령어를 실행하기 위해서는 메모리 접근을 한번 더 해야하는 경우
- 즉 어떤 명령어는 인출-실행, 다른 명령어는 인출-간접-실행 순으로 사이클이 돌아간다

## 인터럽트(interrupt)

- 방해하다, 중단시키다
- CPU가 수행 중인 작업은 방해를 받아 중단할수 있는데, 이 CPU 작업을 방해하는 신호를 **인터럽트**라고 한다.
- CPU가 꼭 주목해야할때, CPU가 먼저 처리해야 할 급한 작업이 생겼을때 발생

## 인터럽트의 종류

- 동기 인터럽트(synchronous interrupt)
  - CPU에 의해 발생하는 인터럽트
  - CPU가 명령어들을 수행중 예상치 못한 상황에 마주했을때 발생
  - 프로그래밍 오류와 같은 예외적 상황에 발생
  - **예외**(Exception)이라고 부른다.
- 비동기 인터럽트(asynchronous intterupts)
  - 주로 입출력 장치에 의해 발생하는 인터럽트
  - 예시1. 입출력 작업을 끝낸 프린터가 CPU에게 완료 인터럽트를 보냄
  - 예시2. 마우스 키보드에 입력이 들어왔을때 이를 CPU에게 알리기 위해 입력 인터럽트를 보냄
  - **하드웨어 인터럽트**라고도 불림

## 하드웨어 인터럽트는 왜 필요한가?

- CPU는 입출력 작업 도중에도 명령어를 처리해야하므로, 하드웨어 인터럽트를 사용
- 만약 인터럽트가 없다면, 하드웨어가 완료됨을 확인하기 위해 주기적으로 완료 여부를 확인 => CPU 사이클 낭비
- 인터럽트가 올때까지 자기 할일을 계속 하고 있기만 하면 됨

## 하드웨어 인터럽트 처리 순서

1. 입출력 장치에서 CPU에 **인터럽트 요청 신호**를 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 인터럽트 여부를 확인
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일수 있는 지 여부를 확인
4. 인터럽트를 받아들일수 있다면, CPU는 지금까지의 작업을 따로 저장해둠
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 저장해 둔 작업을 복구하여 실행을 재개

## 처리 순서 상세

- 인터럽트 요청 신호: 입출력 장치가 CPU에게 보내는 신호
- CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 **인터럽트 플래그가 활성화** 되어 있어야함
- 인터럽트 플래그는 하드웨어 인터럽트를 받아들일지 무시할지를 결정
- CPU가 중요한 작업을 처리해야 하거나 어떤 방해도 받지 않으려 할때 인터럽트 플래그 불가능 설정
- 불가능시 CPU는 인터럽트 무시, 가능시 인터럽트 요청 신호를 받아들이고 인터럽트 처리 시작
- 인터럽트가 불가능 설정이 되어 있어도 무시 할수 없는 인터럽트 요청도 있음
- 무시 할수 없는 인터럽트는 가장 우선순위가 높은, 가장 먼저 처리해야할 인터럽트 ex) 정전, 하드웨어 고장
- CPU가 인터럽트를 받아들이면 **인터럽트 서비스 루틴**이라는 프로그램을 실행
- **인터럽트 서비스 루틴(ISR: Interrupt Service Routine)** 혹은 **인터럽트 핸들러**(interrupt handler)라고 불린다
- 인터럽트 서비스 루틴은 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야할지에 대한 정보로 이루어진 프로그램
- 인터럽트 마다 처리하는 방식이 다르므로, 각자 다른 인터럽트 서비스 루틴을 가지고 있다
- CPU는 인터럽트 서비스 루틴을 구분하기 위해 **인터럽트 벡터**(interrupt vector)를 이용
- **인터럽트 벡터**는 인터럽트 서비스 루틴을 식별하기 위한 정보
- 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알수있어, CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행 가능
- CPU는 인터럽트 요청을 보낸 대상으로 부터 데이터 버스를 통해 인터럽트 벡터를 전달 받음
- 예를들어 키보드 인터럽트는 인터럽트 요청 신호와 해당 인터럽트 벡터를 같이 보낸다.
- 인터럽트 서비스 루틴도 보통 프로그램처럼 명령어와 데이터로 이루어져 있다.(메모리 상에 존재)
- 즉 인터럽트 서비스 루틴도 CPU의 프로그램 카운터 + 레지스터를 일반 프로그램 처럼 사용
- 인터럽트 발생전까지 레지스터에 있던 값들을 서비스 루틴이 끝나면 되돌아와서 마저 수행 해야하기 때문에 저장해둬야함
- CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 **스택**에 저장
- 스택 저장후 인터럽트 서비스 루틴의 시작 주소로 프로그램 카운터를 갱신하고 서비스 루틴 시작
- 인터럽트 서비스 루틴 종료후 스택에 저장한 값들을 불러오고 원래 실행으로 돌아감
- 이를 인터럽트 사이클이라고 한다

## 사이클

- 기본은 인출사이클 <=> 실행 사이클
- 만약 인출사이클후 만약 메모리 접근이 더 필요하면, 인출사이클 -> 간접사이클 -> 실행 사이클
- 실행사이클 종료후 인터럽트 요청이 있고, 인터럽트 플래그가 활성화 되어 있다면 인출사이클로 돌아가지 않고 실행사이클 종료 -> 인터럽트 사이클 -> 인출 사이클

## 예외의 종류(동기 인터럽트)

1. 폴트(Fault)
2. 트랩(trap)
3. 중단(abort)
4. 소프트웨어 인터럽트(software interrupt)

- 예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리, 처리가 끝나면 다시 CPU는 본래하던 작업으로 돌아감
- 돌아갈때 예외 발생한 명령어부터 실행 => **폴트**, 발생한 명령어 다음 명령어부터 실행 => **트랩**

- 폴트의 예시
  - 명령어 실행을 위한 데이터가 메모리가 아닌 보조기억장치에 존재
  - 폴트를 발생시키고, 보조기억장치의 데이터를 메모리로 가져옴
  - 다시 해당 명령어를 실행
- 트랩은 예시
  - 주로 디버깅할때 사용
  - 디버깅할때 특정 코드가 실행 되는 순간 프로그램의 실행을 멈춤
  - 프로그램을 다시 실행시킬때는 다음 명령어부터 실행 재개 => 트랩
- 중단 : CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류
- 소프트웨어 인터럽트: **시스템 호출**이 발생했을때, 운영체제에서 학습
