# 실행 컨텍스트(Execution Context)

- 실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아 놓은 **객체**로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다.
- 호이스팅, this, 외부 환경 정보를 구성하는 등 동작을 수행
- 클로저를 지원하는 대부분의 언어에 유사하거나 동일한 개념이 적용

## 실행 컨텍스트

- **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**
- 특정 동일한 조건, 환경의 코드 덩어리들을 실행할때 필요한 조건/환경정보를 모아둠
- 실행 컨텍스트를 구성하는 방법으로는 전역공간, eval() 함수, 함수, module 등이 있다.
- 전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경이 별도로 제공하는 객체,  
  즉 전역 객체를 이용한다. 전역 객체에는 브라우저의 window , Node.js의 global 객체 등이 있다.
- 자동 생성되는 전역공간, 잘 쓰지않는 eval()함수를 제외하고 보통은 함수를 실행해서 생성한다.(ES6부터 블록({})에서도 가능)
- 구성

1. VariableEnvironment  
   현재 컨텍스트 내의 식별자들에 대한 정보+ 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로 변경사항은 반영되지 않음
2. LexicalEnvironment  
   처음에는 VariableEnvironment와 같지만 변경사항이 실시간 반영
3. ThisBinding  
   this 식별자가 바라봐야할 대상 객체

## VariableEnvironment

- **식별자의 정보를 수집**
- VariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행시의 스냅샷을 유지한다.  
  (스냅샷이란? 특정 시간에 데이터 저장 장치의 상태를별도의 파일이나 이미지로 저장하는 기술로, 스냅샷 기능을 이용하여 데이터를 저장하면 유실된 데이터 복원과 일정 시점의 상태로 데이터를 복원할 수 있습니다.)
- 실행 컨텍스트를 생성할때 VariableEnvironment에 정보를 먼저 담고,  
  이를 그대로 복사해서 LexicalEnvironment를 만들고,  
  그 이후는 주로 LexicalEnvironment를 사용한다.

## LexicalEnvironment

- **각 식별자의 데이터를 계속 추적**
- 어휘적 환경, 정적 환경등으로 번역
- 백과사전이라고 이해하면 편함
- 컨텍스트를 구성하는 환경 정보들을 사전처럼 모아둔것
- enviromentRecord와 outerEnviromentReference로 구성됩니다.

## environmentRecord와 호이스팅

현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.  
 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체(정의까지), var로 선언된 변수의 식별자 등등  
 **코드 실행 전** 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑으며 **순서대로** 수집한다.  
 => `우리가 알고있는 호이스팅의 정체!`, 코드 실행전 모든 변수명을 미리 알고 있다.

## 호이스팅

- 끌어올리다 hoist + ing
- 변수는 선언부와 할당부를 나누어 선언부만 끌어올린다.

```js
var x;// 이거만


x=3;
--------------------
var x = 3;
```

- 함수는 선언은 함수 전체를 끌어올린다. (정의까지 다 같이)

```js
var sum = function sum(a,b){ return a+b; }// 선언형 => 할당한것 처럼 전부 끌어올린다.
//즉 만약 sum이라는 일반적인 변수가 미리 선언되면 sum이라는 fucntion이 뒤에서 선언됐을경우 해당 변수는 없고 전부 함수로 치환된다.
---------------------------------
function sum(a,b){
 return a+b;
}
```

## 함수 선언문과 함수 표현식의 호이스팅

[함수 종류](./05.%20%ED%95%A8%EC%88%98.md) 참고

함수 선언문은 함수 정의까지 전체를 호이스팅하고, 함수 표현식은 변수 선언부만 호이스팅이 일어나게 된다. 즉 선언문은 어디 선언되든 호이스팅으로 함수 호출이 정상 진행된다.

이 때문에 **보통 함수 표현식을 주로 권장한다**

- 함수가 선언되고 사용된다는 일반적인 개념을 생각할때, 함수 표현식을 쓰는게 옳다.
- 모르고 같은 이름을 가지고 구현이 다른 함수를 같은 컨텍스트내에서 함수 선언문으로 생성하면, 호이스팅이 일어나 먼저 선언된 함수는 뒤에 선언된 함수로 덮어씌어진다. 즉 의도치 않게 다른 함수가 하나로 통일된다.
- 둘다 함수 표현식이였다면, 선언이후에 사용되면 함수는 그 선언을 각각 따라가게 된다.

## 스코프

- 스코프란 식별자에 대한 유효범위
- 외부에서 선언한 변수는 내부에서도 접근 가능하지만, 내부에서 선언한 변수는 외부에서 접근 불가
- 자바스크립트는 전역공간을 제외하면 오직 함수에 의해서만 스코프 생성(ES5까지)
- ES6 문법부터 블록에 의해서도 스코프가 생성된다. `var`로 선언한 변수에는 적용되지 않고, `let` `const`,`class`등 ES6 문법등에서 그 역할을 수행
- 따라서 구별을 위해 ES6부터 `함수 스코프`, `블록 스코프` 로 분리됨

## 스코프 체인, outerEnvironmentReference

- 스코프 체인은 식별자의 유효범위를 안에서부터 바깥으로 차례대로 검색해 나가는 것
- 이를 가능하게 해주는것이 LexicalEnvironment의 `outerEnvironmentReference`
- outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조한다.
- 즉 내부 컨텍스트로 새로 들어갈때 그 컨텍스트의 outerEnviromentReference는 외부 컨텍스트가 어디까지 기억한 상태인지 정보를 기억하게 된다.
- 각 outerEnviromentReference는 오직 자신이 선언된 시점의 LexicalEnvironment만 참조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할수있고, 다른 순서로는 접근 불가능
- 즉 여러 스코프에 동일한 식별자를 선언한경우 `무조건 스코프 체인 상에서 가장 먼저 발견된 식별자`에만 접근이 가능하다.
- 전역 공간에 선언한 동일한 이름의 변수가 내부공간에도 있을경우 전역공간의 해당 변수에는 접근이 불가능하고 이를 `변수 은닉화`라고 한다.

## 전역 변수와 지역변수

- 전역공간에 선언한 벼수는 전역변수, 함수 내부에 선언한 변수는 지역변수

## thisBinding

실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장됩니다, this가 지정되지 않은 경우 this에는 전역 객체가 저장됩니다. 그밖에 함수 호출법에 때라 this에 저장되는 대상이 다릅니다.
