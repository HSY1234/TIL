# DTO VS VO

웹개발에서 사용되는 VO는 거의 DTO이다.  
DTO를 VO처럼 불변 객체로 사용하면 얻을 수 있는 이점? => DTO가 전송하고자 하는 데이터가 변조되지 않음을 보장

## DTO (Data transfer object)

- 레이어 간 **데이터를 전달**하는 객체
- 데이터 접근 메서드 외에 기능을 가지지 않음
  - 정렬 직렬화 등 데이터 표현을 위한 기능을 가질 수 있음
- 데이터 캡슐화를 통해 유연한 대응이 가능함
  - 데이터 요청 수 감소 효과
- 데이터 교환만을 위해 사용하므로 로직을 갖지 않고, getter/setter 메소드만 갖는다.
- 불변성을 보장하는 DTO를 만들기 위해 setter없애고 초기 Constructor만 있고 이를 써서 불변성을 유지하는 경우도 있다. 멤버는 Private로 사용하는 경우도 있다.
- 속성값이 모두 같다고해서 같은 객체가 아니다!

## VO (Value Object)

- **값을 표현**하는 객체
- 값 자체로 의미를 가지는 객체
- 변하지 않는 값을 가지는 객체
  - 값이 변하지 않음을 보장하여 코드의 안정성과 생산성을 높임
- 값이 같다면 동일한 객체
  - 각 객체를 비교하는데 사용되는 ID가 없음
  - 같은 객체인지 판단하기 위해 각 속성들의 값을 비교함
  - 이를 위해 equals() 와 hashCode()를 오버라이딩 해야한다.
  - JAVA에서 객체의 비교순서는 hashcode() => equals()다
  - hashCode는 멤버변수의 특정값으로 해쉬값을 return하도록 (ex `return Objects.hash(멤버변수)`)
  - equals는 멤버변수 값끼리 비교하도록 구현

## 공통점

- 레이어 간 데이터 전달할 때 사용 가능
- VO는 불변을 보장하기 때문에 데이터 전달 용도로 사용가능

## 차이점

- DTO

  - 값이 변할수 있음
  - 레이어와 레이어 사이에서 사용
  - DTO의 멤버값이 완전히 동일해도 같은 DTO가 아님
  - 데이터 접근이외의 기능을 가지지 않음

- VO

  - 값이 변하지 않음
  - 모든 레이어에서 사용 가능
  - 멤버 값이 완전히 동일하면 같은 VO(이름이 다르더라도)
  - 특정한 비즈니스 로직을 가질 수 있음

- Entity
  - 값이 변할수 있다.
  - 로직을 가질수 있다.

# Entity

- 실제 DB의 데이터와 매핑되는 클래스
- Id로 구분된다.
- 로직을 포함할 수 있다.
- 절대로 요청이나 응답값을 전달하는 클래스로 사용하면 안된다!
- Entity class를 기준으로 테이블이 생성, 스키마가 변경되기 때문이다.
- 따라서 요청이나 응답을 위한 DTO는 따로 만들어서 사용하는게 옳다

## Entity를 DTO대신 사용할수 있을까?

- 사용할수는 있다.
- View에서 표현하는 속성 값들이 요청에 따라 계속 달라질 수 있는데, 그 때마다 Entitiy의 속성값을 변경하면 영속성 모델을 표현한 Entity의 순수성이 모호해지기 때문에 Controller에서 쓸 DTO와 Entity클래스는 분리하는게 좋다.

## 출처

https://www.youtube.com/watch?v=J_Dr6R0Ov8E
