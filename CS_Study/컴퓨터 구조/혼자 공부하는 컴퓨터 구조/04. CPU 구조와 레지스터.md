# CPU 구조

CPU는 ALU, CU, 레지스터 등으로 구성되어 있다.  
ALU의 구성을 보고 싶다면 디지털 논리 회로를 공부할것

# ALU

ALU는 **레지스터**를 통해 피연산자를 받아들이고,  
제어장치로 부터 수행할 연산을 알려줄 **제어 신호**를 받아  
다양한 연산을 수행 후  
**레지스터**와 **플래그**에 결과값을 보냅니다

- CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느림
- CPU가 계산 할때마다 매번 메모리에 접근 한다면 속도가 매우 느리기 떄문 일단 레지스터에 저장!
- **플래그**는 연산의 결과값 뿐만 아니라 연산결과와 관련된 다른 정보를 제공
  - 결과는 음수
  - 결과값이 너무 크다(레지스터 보다)
  - 등등...

## 플래그(flag)

CPU가 프로그램 실행중 반드시 기억해야할 참고 정보  
플래그 레지스터에 저장

- 부호 플래그: 계산 결과의 부호
- 제로 플래그: 0인지 여부
- 캐리 플래그: 올림수나 빌림수가 발생했는지
- 오버 플로우 플래그: 오버플로우가 발생했는지
- 인터럽트 플래그: 인터럽트가 가능한지
- 슈퍼바이저 플래그: 커널모드로 실행중인지, 사용자 모드로 실행중인지
- 등등...

## ALU의 내부 구성요소

- 가산기
- 보수기
- 시프터
- 오버플로우 검출기
- ...

# 제어장치

- 제어 신호를 보내고, 명령어를 해석하는 부품
- CPU의 구성 요소중 가장 정교하게 설계, 제조사마다 구현 방식이나 명령어 해석 방식이 다 다름
- 제어장치는 클럭신호, 해석할 명령어, 플래그 레지스터의 플래그, 시스템 버스의 제어 버스로 전달된 제어 신호등을 받아들입니다
- 제어장치는 CPU내부로 제어 신호, CPU 외부로 제어 신호를 내보냅니다.

- 입력

  - 클럭
  - 명령어
  - 플래그
  - 시스템 버스의 제어버스로 들어오는 제어신호

- 출력
  - CPU 내부
    - ALU로 전달하는 제어신호 : 수행할 연산 지시
    - 레지스터에 전달하는 제어신호 : 레지스터간 데이터 이동, 레지스터에 저장된 명령어 해석
  - CPU 외부 : 시스템버스의 제어버스로 제어신호를
    - 메모리로 보내는 신호 : 메모리 쓰기, 메모리 읽기
    - 입출력 장치로 보내는 신호 : 입출력 값 읽기, 입출력 값 쓰기

## 클럭(clock)

- 클럭이란 컴퓨터의 모든 부품이 일사불란하게 움직일수 있게 하는 시간 단위
- 클럭 주기에 맞춰 레지스터의 데이터가 다른 레지스터로 이동, ALU 연산 수행, 메모리 저장된 명령어 읽기등 모든 컴퓨터의 활동은 클럭 기준
- 모든 부품이 한 클럭 단위로 정해지지 않음, 보통 한 명령어는 여러 클럭에 걸쳐 수행됨
- 클럭은 말 그대로 최소 시간 단위이다

## 명령어

- 명령어 레지스터라는 특별한 레지스터에 명령어는 저장되고, CU는 명령어를 여기서 받아들이고 해석한뒤 제어신호를 발생시킴

## 플래그

- 플래그 레지스터값을 받아들이고 제어신호를 발생

## 제어버스로 전달된 제어신호

- 제어 신호는 CPU만이 아니라, 메모리, 입출력장치같은 외부에서도 발생 가능
- 외부에서 시스템버스의 제어버스로 제어신호를 보냄

# 레지스터

- 프로그램 속 명령어와 데이터는 반드시 레지스터에 저장
- 반드시 알아야하는 레지스터
  - 프로그램 카운터
  - 명령어 레지스터
  - 메모리 주소 레지스터
  - 메모리 버퍼 레지스터
  - 플래그 레지스터
  - 범용 레지스터
  - 스택 레지스터
  - 베이스 레지스터

## 프로그램 카운터(PC: program counter)

- 메모리에서 가져올 명령어 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장
- 프로그램 카운터를 **명령어 포인터(Instruction Pointer)**라고 부르는 CPU도 있음
- 특별한 일 없으면 명령어 호출할때 마다 꾸준히 증가
- 명령어 중 JUMP, CONDITIONAL JUMP, CALL , RET 같이 특정 주소로 실행 흐름을 이동하면 그 주소로 변경
- 혹은 인터럽트 발생시

## 명령어 레지스터(IR: Instruction Register)

- 방금 메모리에서 가져온 명령어를 저장하는 레지스터
- CU는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 보냄

## 메모리 주소 레지스터(MAR: Memory Address Register)

- 메모리 주소를 저장하는 레지스터
- CPU가 **읽으려고 하는 주소 값**을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침

## 메모리 버퍼 레지스터(MBR: Memory Buffer Register)

- 메모리 버퍼 레지스터는 메모리와 주고받을 값(데이터와 명령어)를 저장하는 레지스터
- 메모리에 **쓰고 싶은 값**이나 메모리로부터 **전달받은 값**은 메모리 버퍼 레지스터를 거친다.
- CPU가 주소 버스로 내보낼 주소 값이 메모리 주소 레지스터, 데이터 버스로 주고 받을 값(데이터)은 메모리 버퍼 레지스터
- 메모리 데이터 레지스터(MDR: Memory Data Register)라고도 함
- 데이터 버스로 주고 받은 값만 저장한다

## 예시 프로그램 실행시

1. PC의 1000번지 => 메모리 주소 레지스터(MAR)로 보냄
2. 제어장치에 의해 MAR의 값은 주소 버스로, 제어 신호는 제어버스로 메모리로 전달
3. 메모리에서 데이터 버스로 해당 데이터를 보내고, MBR에 해당 데이터 값을 저장
4. PC 카운터 다음번지(1001)로 증가
5. 메모리 버퍼 레지스터의 값을 IR로 이동(가져온게 명령어 데이터니까)

## 범용 레지스터(general purpose register)

- 이름 그대로 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
- 메모리 버퍼는 데이터 버스로 주고 받은 값만 저장하고, 메모리 주소 레지스터는 주소 버스로 보낼 주소만 기억함
- 즉 데이터 & 주소나 아무거나 저장할수 있는 레지스터가 따로 필요하고 범용레지스터가 그역할을 한다
- CPU에는 보통 여러개의 범용 레지스터가 있다

## 플래그 레지스터(flag resgister)

- ALU 연산결과에 따른 상태(플래그)들을 저장하는 레지스터
- CPU의 부가적인 정보를 저장

# 특정 레지스터를 이용한 주소 지정 방식

- 스택 포인터(stack pointer): 스택 주소 지정 방식에 사용, 스택의 꼭대기를 가리키는 레지스터
- 베이스 레지스터: 변위 주소 지정 방식에 프로그램 카운터(PC)와 함께 쓰임

## 스택 주소 지정 방식

- 스택과 **스택 포인터**를 이용한 주소 지정 방식
- 스택포인터는 스택 꼭대기를 가리키는 레지스터로 스택이 마지막으로 저장한 값의 위치를 저장
- 스택은 메모리 안에 있음, 메모리 안에 스택처럼 사용할 영역이 지정되어 있고, 이를 **스택 영역**이라고 함

## 변위 주소 지정 방식(displacement addressing mode)

- 변위 주소 지정 방식이란 **오퍼랜드 필드의 값**과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
- 변위 주소 지정 방식을 사용하는 명령어 = 연산코드 + 레지스터+ 오퍼랜드 조합으로 이루어짐
- 여기서 또 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식으로 구분됨

### 상대 주소 지정 방식(relative addressing mode)

- 오퍼랜드와 PC값을 더하여 유효주소를 얻는 방법
- 명령어 = 연산코드 + 프로그램 카운터(이것도 레지스터니까) + 프로그램 카운터에 더할 오퍼랜드 값
- ex) +3이면 3명령어 건너뜀, -3이면 3명령어 전으로
- 상대 주소 지정 방식은 프로그래밍 언어의 if문 처럼 분기하여 특정 주소 실행할때 사용

### 베이스 레지스터 주소 방식(base-register addressing mode)

- 오퍼랜드와 베이스 레지스터의 값을 더하여 유효주소를 얻는 방법
- 베이스 레지스터 = 기준 주소, 오퍼랜드 = 기준주소로부터 떨어진 값
- 명령어 = 연산 코드 + 베이스 레지스터 + 오퍼랜드
- 6장 참고
