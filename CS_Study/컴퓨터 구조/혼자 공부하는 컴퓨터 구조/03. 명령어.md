# 명령어

- 모든 소스코드는 결과적으로 컴퓨터 내부에서 명령어로 변환

## 고급 언어 & 저급 언어

- 고급 언어
  - 컴퓨터는 이해 불가
  - 사람을 위한 언어
  - C, C++, JAVA, python
- 저급 언어
  - 컴퓨터가 직접 이해학 실행가능한 언어
  - 기계어(machine code, 0과1)
  - 어셈블리어
  - 두개뿐이다

기계어가 사람이 읽으면 해석하기 힘들기 떄문에 1대1 대응이 되는 어셈블리어 등장

어셈블리어는 한 줄 한 줄이 명령어이다.

저급 언어의 중요성은 분야에 따라 다르다.(주로 임베디드, 게임, 보안 분야)

어셈블리어를 읽으면 컴퓨터 프로그램이 어떤 과정으로 실행하는지, 어떤 절차로 작동하는지 근본적인 단계를 이해할수 있기 때문에 중요하다

# 컴파일 언어 VS 인터프리터 언어

- 최근에는 경계가 모호한 경우가 많음

## 컴파일 언어

- 컴파일러에 의해 소스 코드가 전체가 저급 언어로 변환되어 실행되는 고급 언어
- 고급 언어의 소스 코드 전체가 저급 언어로 변환되는 과정을 **컴파일**이라고 부른다 - 컴파일을 수행해 주는 도구를 **컴파일러**라고 함 => 번역기라고 생각
- 엄밀히 따지면 A 고급 언어 <-> B 고급 언어도 컴파일이라고 할 수 있다.(이 경우 transcompiler라고 부름)
- 기계어 -> 고급 언어는 decompiler라고 부른다
- 컴파일러는 소스 코드 전체를 훑어보며 소스 코드에 문법적인 오류는 없는지, 실행가능한지, 불필요한 코드는 없는지 체크해준다(요즘은 최적화도 다 해줌)
- 저급 언어로 컴파일된 코드를 목적코드(object code)라고 한다

## 인터프리터 언어

- 인터프리터에 의해 소스 코드가 한 줄씩 실행된느 고급언어
- 컴파일 언어와 달리, 소스 코드를 한줄씩 차례대로 실행. 이 도구를 **인터프리터(interpreter)**라고함
- 소스 코드 전체가 저급 언어로 변환하는 시간을 기다릴 필요가 없다.
- 컴파일언어와 달리 문법오류나 실행불가능한 소스코드 줄을 만나기 전까지 실행이 된다.

## 목적 파일 VS 실행 파일

- 목적 코드로 이루어진 파일을 목적 파일이라고 한다
- 실행 코드로 이루어진 파일을 실행 파일이라고 한다(ex 윈도우의 .exe 파일)
- 목적 파일 ≠ 실행 파일
- 목적 파일이 실행 파일이 되기 위해서는 **링킹(linking)**을 거쳐야 한다
- 원칙적으로 컴파일러는 프로그램을 기계어로 바꾸기만 할 뿐 이를 바로 실행이 가능하게 하지는 않는다. 여러 소스 파일에서 나온 결과물을 합치고 라이브러리도 포함시키는 등 별도의 작업을 거쳐야 실행이 가능해지는데 이를 수행하는 프로그램이 링커이다.
- a.c -> a.o , b.c -> b.o 만약 a 소스에서 b 소스를 가져와서 사용하는 함수가 있다면 각 파일에서만 실행불가, 링커가 연결해준다

## 컴파일과 링킹?

## JAVA의 컴파일 구조 + 인터프리터 구조

# 명령어의 구조

- 연산 코드
- 오퍼랜드
- 주소 지정 방식

## 연산코드와 오퍼랜드

- 명령어는 무엇을 대상으로 무엇을 실행할지가 핵심
- 무엇을 실행할지 = 연산 코드(opcode, 연산자)
- 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치 = 오퍼랜드(operand, 피연산자)
- 하나의 명령어에 연산코드가 담기는 영역을 **연산 코드 필드**, 오퍼랜드가 담기는 영역을 **오퍼랜드 필드**라고 함

## 오퍼랜드

- 연산에 사용될 데이터(숫자, 문자와 같은 연산에 사용될 데이터를 직접 명시= 상수 값)
- 연산에 사용될 데이터가 저장된 위치(메모리 주소 or 레지스터 이름) => 그래서 오퍼랜드 필드를 **주소 필드**라고 부르기도함
- 연산의 종류에 따라 오퍼랜드가 0개, 1개, 2개, 3개 이상일수 있음
  - 0-주소 명령어 : 연산 코드
  - 1-주소 명령어 : 연산 코드 + 오퍼랜드
  - 2-주소 명령어 : 연산 코드 + 오퍼랜드 + 오퍼랜드
  - 3-주소 명령어 : 연산 코드 + 오퍼랜드 + 오퍼랜드 + 오퍼랜드

## 연산코드

cpu마다 명령어가 다르기 때문에, 연산코드도 다르다.

연산코드의 종류는 많지만 기본적인 연산은 4종류정도로 분류

- 데이터 전송
  - MOVE : 데이터 이동
  - STORE : 데이터 저장
  - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
  - PUSH : 스택에 데이터를 저장하라
  - POP : 스택 최상단 데이터를 가져와라
- 산술/논리 연산
  - ADD / SUBTRACT / MULTYPLY / DIVIDE : 덧셈/ 뺄셈/ 곱셈 / 나눗셈
  - INCREMENT / DECREMENT : ++, --
  - AND / OR / NOT : AND / OR / NOT 연산 실행
  - COMPARE : 두 숫자 OR TRUE FALSE 비교
- 제어 흐름 변경
  - JUMP : 특정 주소로 실행 순서를 옮기기
  - CONDITIONAL JUMP : 조건에 부합할때 특정 주소로 실행 순서를 옮기기
  - HALT : 프로그램 실행 종료
  - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서 옮기기
  - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가기
- 입출력 제어

  - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
  - WRITE(OUTPUT) : 특정 입출력 자이촐 데이터를 써라
  - START IO : 입출력 장치를 시작해라
  - TEST IO : 입출력 장치의 상태를 확인해라

# 주소지정 방식(addressing mode)

오퍼랜드에 메모리나 레지스터 주소를 담지 않고 바로 데이터를 직접 넣는게 낫지 않나요? => 명령어 길이 때문에 힘듬

연산코드 길이를 명령어 길이에서 빼고 남는 자리에 데이터를 넣어야하는데, 그마저도 데이터 수가 많으면 모두 표현할 자리가 없음

ex) 16비트에서 만약 opcode 4비트인 경우, 이를 빼면 12비트인데 데이터 12비트는 너무 적음 + 2개면 6비트, 3개면 4비트

데이터가 아닌 주소를 저장하면, 주소의 종류가 2^n개가 되고, 해당 주소에 다양한 종류의 데이터를 가져 올수있다.

- 유효주소(effective address): 연산 코드에 사용될 데이터가 저장된 실제 위치
- 주소 지정 방식(addressing mode): 유효주소에 접근하기 위한 방법, 종류가 매우 많음
  - 묵시적 지정 방식
  - 즉시 주소 지정 방식
  - 직접 주소 지정 방식
  - 간접 주소 지정 방식
  - 레지스터 주소 지정 방식
  - 레지스터 간접 지정 방식
  - 계산에 의한 주소 지정 방식

## 묵시적 주소(Implied Address, 암시적)지정방식

- 주소를 지정하는 필드가 없는 0번지 명령어에서 Stack의 Top 포인터가 가리키는 Operand를 암시하여 이용함
- 주소를 따로 지정하지 않아도 묵시적으로 알고 있는 주소를 암시

## 즉시 주소 지정 방식(immediate addressing mode)

- 데이터를 주소를 사용하지 않고 직접 오퍼랜드 필드에 명시하는 방법
- 장점: 메모리나 레지스터로 부터 찾을 필요 X, 가장 빠름
- 단점: 표현할수있는 데이터 크기가 작음

## 직접 주소 지정 방식(direct addressing mode)

- 오퍼랜드필드에 유효주소를 직접적으로 명시하는 방식
- 장점: 즉시 주소 지정 방식보다는 표현할수있는 데이터 양이 많아졌지만,
- 단점: 유효주소를 표현할수 있는 범위가 연산코드만큼 줄어서 짧다

## 간접 주소 지정(indirect addressing mode)

- 유효주소의 주소를 저장한 메모리 주소를 오퍼랜드 필드에 명시 (즉 오퍼랜드 주소 접근 => 해당 주소의 저장된 주소로 다시 메모리 접근 => 유효주소)
- 장점: 직접 주소 지정 방식 보다 메모리 유효주소의 범위가 넓어짐
- 단점: 메모리 접근을 두번해야해서 느림

## 레지스터 주소 지정(register addressing mode)

- 직접 주소 지정 방식과 비슷하게 메모리가 아닌 레지스터 주소를 명시해, 해당 주소에 저장된 데이터를 가져오는 방식
- 레지스터는 메모리보다 빠름
- 레지스터의 크기에 따라 데이터의 제한이 있음

## 레지스터 간접 지정 (register indirect addressing mode)

- 유효주소를 저장한 레지스터의 주소를 오퍼랜드 필드에 명시
- 간접 주소 지정과 비슷하지만 메모리 => 메모리가 아닌, 레지스터 => 메모리라 속도가 더 빠름

## 다른 주소 지정 방식

- 스택 주소 지정 방식
- 변위 주소 지정 방식
  - 상대 주소 지정 방식
  - 베이스 레지스터 주소 지정 방식

[04장 CPU구조와 레지스터 참고](04.%20CPU%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0.md)
