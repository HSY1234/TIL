# 입출력 방법

- 장치 컨트롤러는 CPU와 어떻게 데이터를 주고 받을까?
- 프로그램 입출력
- 인터럽트 기반 입출력
- DMA 입출력

## 장치 컨트롤러의 구성

- 데이터 레지스터(data register) : CPU와 입출력장치 사이에 주고 받는 데이터가 담기는 레지스터 => 버퍼 역할 (최근에는 주고받는 데이터가 많은 경우 입출력장치에도 RAM을 두고 대신 사용)
- 상태 레지스터(status register) : 입출력장치가 입출력 작업을 할 준비가 되었는지. 작업이 완료 되었는지, 오류가 없는지 상태 저장
- 제어 레지스터(control register) : 입출력장치가 수행할 내용에 대한 제어정보와 명령을 저장
- 등등

# 프로그램 입출력(programmed I/O)

- 프로그램 속 명령어로 입출력 장치를 제어하는 방법
- CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력장치에 연결된 장치 컨트롤러와 상호작용하면서 입출력 작업을 수행

- 예시. 메모리의 데이터를 하드디스크에 저장

  1. CPU는 하드디스크 컨트롤러에 제어 레지스터에 쓰기 명령을 보냄
  2. 하드디스크 컨트롤러는 하드 디스크 상태를 확인
  3. 준비가 됐다면 하드 디스크 컨트롤러의 상태 레지스터에 준비됐다고 변경
  4. CPU는 주기적으로 상태 레지스터를 확인
  5. 준비됐음을 확인하면 쓸 데이터를 데이터 레지스터에 쓴다
  6. 모든 데이터가 하드디스크에 써질때까지 1~5 반복
  7. 모든 데이터가 하드디스크에 써졌다면 종료

- CPU는 장치 컨트롤러의 레지스터값을 읽고 쓰면서 진행
- 그런데 CPU는 어떻게 장치 컨트롤러의 레지스터의 주소를 알수 있을까?
- CPU 내부 레지스터와 달리 장치 컨트롤러의 모든 레지스터를 CPU가 알고 있기가 어렵다
- 특히, 이것들이 명령어에서 어떻게 표현되는지를 이해해야함
  - 메모리 맵 입출력
  - 고립형 입출력

## 메모리 맵 입출력(memory-mapped I/O)

- 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소공간을 하나의 주소 공간으로 취급하는 방법
- 장치 컨트롤러의 레지스터의 주소 역시 메모리 주소 접근하듯이 접근하면 된다
- 굳이 명령어가 다를 필요가 없음
- 대신 메모리 주소 공간이 축소됨(같이 쓰니까)

## 고립형 입출력(isolated I/O)

- 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법
- 메모리는 메모리 읽기/쓰기, 입출력장치1은 입출력장치1 읽기/쓰기, 입출력장치2는 입출력장치2 읽기/쓰기
- 주소 공간을 따로 활용
- 즉 입출력 전용 명령어가 따로 있다
- 메모리 주소 공간이 축소되지 않음

# 인터럽트 기반 입출력(Interrupt-Drive I/O)

- 하드웨어 인터럽트(비동기 인터럽트)
- CPU는 입출력장치가 명령을 수행하는 동안 다른 일을 하고, 입출력장치가 인터럽트 요청을 보내면 CPU는 일을 멈추고 인터럽트 서비스 루틴을 실행함
- 이를 인터럽트 기반 입출력이라고 함

## 하드웨어 인터럽트 처리 순서

1. 입출력 장치에서 CPU에 **인터럽트 요청 신호**를 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 인터럽트 여부를 확인
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일수 있는 지 여부를 확인
4. 인터럽트를 받아들일수 있다면, CPU는 지금까지의 작업을 따로 저장해둠
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 저장해 둔 작업을 복구하여 실행을 재개

## 폴링(polling) VS 인터럽트

- 폴링은 특정주기마다 스레드를 돌면서 시그널이 있는지 소프트웨어적으로 확인
- 프로그램 입출력에서 주기적으로 장치 컨트롤러의 상태 레지스터를 확인하며 입출력장치의 상태를 확인하는게 전형적인 폴링 (풀링 아님!)
- 주기마다 확인하므로 리소스를 많이 먹고, 정확한 타이밍이 아닌 주기마다만 감지가능 즉 오차가 있다.
- 그러나 구현이 쉽고, 우선순위 변경이 쉬움

## 인터럽트가 동시다발적으로 발생한다면?

- 마우스, 키보드, 모니터, 스피커 등등 입출력 인터럽트는 동시에 여러개 발생가능
- 가장 쉬운 방법은 들어온 순서대로 인터럽트를 처리하기(순차적으로 해결)
  - A 인터럽트 서비스 루틴 진행중이면, B요청은 받지 않고 끝날때까지 대기
  - 플래그 레지스터중 인터럽트 비트를 비활성화해서 받지 않는 형식으로 구현
- 모든 인터럽트를 순차적으로 해결할수만은 없다. 더 빨리 처리해야하는 인터럽트도 존재
- CPU는 인터럽트간의 우선순위를 고려해야 한다.
- 예를 들어 A 인터럽트 서비스 루틴을 진행중 , 우선순위가 더 높은 B인터럽트가 들어오면 일반적인 인터럽트 처럼 A 서비스 루틴을 저장해두고, B 인터럽트 서비스 루틴을 끝내고 다시 복귀해야한다
- 플래그 레지스터 속 인터럽트 비트가 활성화 된 경우나, 인터럽트 비트가 비활성화 상태여도 무시 할수 없는 인터럽트 **NMI(Non-Maskable Interrupt)**가 발생하는 경우 CPU는 해당 인터럽트부터 처리

## PIC(프로그래머블 인터럽트 컨트롤러, Programmable Interrupt Controller)

- 우선순위를 반영하여 다중 인터럽트를 처리하는 방법 중 하나(가장 많이 사용)
- PIC는 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에게 지금 처리해야 할 하드웨어 인터럽트를 알려줌
- PIC 하드웨어에 여러핀이 존재하고, 각 핀은 각각 하드웨어와 연결되어 인터럽트를 받음
- PIC의 다중 인터럽트 처리 과정
  1. PIC가 인터럽트 요청 신호 들을 받아들임
  2. 우선순위를 판단한뒤 CPU에 처리해야할 인터럽트 요청 신호를 보냄
  3. CPU는 PIC에 인터럽트 확인 신호를 보냄
  4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보냄
  5. CPU는 인터럽트 벡터를 통해 인터럽트 요청한 하드웨어 정보를 알게되고, 해당 장치의 서비스 루틴을 실행
- 복잡한 장치들을 관리하기 위해 PIC를 계층형태로 만들어서 일반적으로 관리(PIC각 핀에 PIC들을 연결해서 연결 가능한 장치수를 늘림, 어차피 CPU는 인터럽트 1개만 처리하니까)
- PIC는 NMI는 우선순위 판별 X, NIM은 최상위 우선순위이므로 판별할 이유가 없다. PIC가 우선순위를 조정하는 인터럽트는 인터럽트 비트를 통해 비활성화가 가능한 인터럽트 범주

# DMA 입출력(Direct Memory Acess)

- 모든 입출력 장치가 CPU를 거쳐야 한다면 CPU의 부담이 너무 큼(하드디스크 백업 처럼 대용량 데이터)
- 입출력 장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식등장
- DMA는 이름 그대로 직접 메모리에 접근할 수있는 입출력 기능이다. DMA 입출력을 하기 위해서는 시스템 버스에 연결된 **DMA 컨트롤러**라는 하드웨어가 필요
- CPU를 거치지 않고, 메모리와 입출력장치간의 데이터를 주고받을수 있다는게 핵심!

## DMA 입출력 과정

1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산(읽기/쓰기), 읽거나 쓸 메모리의 주소 등을 으로 입출력작업 명령
2. DMA 컨트롤러는 CPU대신 장치 컨트롤러와 상호작용하며 입출력 작업 수행, 이떄 DMA 컨트롤러는 필요하다면 메모리에 직접 접근해 정보를 읽고 쓴다
3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝남을 알림

## DMA의 장단점

- CPU는 입출력 명령 후, 인터럽트만 받으면 되기 때문에 작업부담 감소
- DMA 컨트롤러는 시스템버스를 통해 직접 메모리에 접근하기 때문에 CPU와 시스템 버스를 공유
- 시스템 버스는 공유자원이기 때문에, CPU가 사용중일땐 사용 불가, CPU도 DMA가 사용중엔 사용불가
- CPU가 버스를 안쓸때 잠깐 쓰거나, CPU가 못쓰게 막고 집중적으로 이용
- 이를 **사이클 스틸링(cycle stealing)**이라고 한다. (CPU의 버스 주기 도둑)

## 입출력 버스(input/output bus)

- 시스템 버스를 DMA가 자꾸 사용하는 문제를 해결하기 위해 따로 버스를 분리
- CPU, 메모리. DMA 컨트롤러를 같은 시스템 버스로 연결하고
- DMA 컨트롤러와 다른 입출력 장치를 연결하는 입출력버스(input/output bus)를 분리함
- DMA 컨트롤러가 장치 컨트롤러와 서로 데이터를 전송할때는 시스템 버스를 사용할 필요가 없어짐
- 현대 컴퓨터는 대부분 입출력 버스가 있고, 장치 대부분은 입출력버스와 연결
- 입출력 버스에는 **PCI 버스**(Peripheral Component Interconnect), **PCI Express(PCIe)**버스등 다양한 종류가 존재
- PCIe 슬롯 : 입출력장치들을 PCIe 버스와 연결해주는 슬롯을 통해 시스템버스를 타고 CPU와 정보를 주고 받음
- DMA를 통해 메모리와 입출력장치가 CPU를 거치지 않고 직접 데이터를 주고 받을수 있게 되었지만, 여전히 입출력 명령어를 인출하고, 해석하고, 실행하는 역할 대부분은 CPU의 역할
- 최근에는, 입출력 전용 CPU가 따로 존재해서 입출력장치에 내장되어있다
- 이를 입출력 프로세서(I/O Porcessor, IOP), 입출력 채널(I/O Channel)이라고 부름
- 입출력 채널이 있는 컴퓨터에서는 CPU가 명령어를 실행하지 않고, CPU가 입출력 채널에게 메모리에 저장된 특정 입출력 명령어를 수행하라고 지시하면, 입출력 채널이 인출 해석 실행 후 인터럽트 신호를 통해 결과를 CPU에 보냄
