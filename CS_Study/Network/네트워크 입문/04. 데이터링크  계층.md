# 데이터 링크 계층

- **신호가 닿는 범위에서의 데이터 전송에 관한 규정**을 생각한다
- **세그먼트 범위에서 데이터를 어떻게 송수신할지**를 결정 하는게 2계층
- **세그먼트** : 케이블 분배기 or 허브로 연결되는 범위, 신호가 닿는 범위
  - 멀티액세스 네트워크 (허브)
  - 포인트 투 포인트 네트워크 (컴퓨터-라우터, 라우터-라우터)
- 세그먼트를 넘는 범위는 다른 세그먼트로 데이터를 보낸다는 의미 = 3계층의 패킷 교환기 라우터
- 1계층에서 다루는 신호와 케이블에 따라 2계층의 규격이 달라짐 (3계층 이상은 LAN,WAN 상관없이 동일한 규칙 사용)
  - LAN
  - WAN
- LAN용 규칙을을 주로 사용
- **이더넷(Ethernet)** : LAN의 2계층의 사실상 표준
- 세그먼트 내에서의 데이터 전송에 관한 순서
  - 프레이밍

## 1계층에서 문제점

- 허브는 1대에게만 신호를 전송하고 싶어도 모든 기기에 신호를 보낸다
- 동시 송신에서 신호충돌이 발생 => 송신을 엇갈리게 할 방법이 필요!
- **신호의 송신 전이나 수신 후에 바르게 데이터를 송수신하는 순서**가 필요

## 프레이밍(Framing)

- = 프레임화
- 1계층에서 주고 받는 신호를 비트화에서 의미를 갖게 하는것
- **프레임**은 2계층의 PDU
- 프레이밍을 시행함으로써 송수신되는 신호를 데이터로 인식할수 있게 된다
- 프리엠블(preamble) : 네트워크 통신에서 두 개 이상의 시스템간에 전송 타이밍을 동기화하기 위해 사용되는 신호이다. 적절한 타이밍은 모든 시스템들이 정보 전달의 시작을 올바르게 해석할 수 있도록 보장한다. 수신측에서는 프리엠블을 수신하면 이제부터 프레임 신호가 오겠군이라고 판단
- 실제로 프레임 헤더에 프리엠블이 8바이트로 존재 (0과 1의 반복)
- 비트를 읽는 타이밍이 송식측과 수신측 양쪽에서 일치해야 한다
- 타이밍을 맞추는 방법
  - 동기 통신 : 클락신호로 타이밍 맞추는 신호를 계속 보내는 방법
  - 프리엠블: 비트를 읽을 타이밍을 프리엠블에 맞춤, 처음에 어긋나더라도 1과 0의 교대로 읽고 비트 읽는 타이밍을 맞춤, 패킷 통신은 프리엠블이 일반적인 방법

# 주소

- 주소(address) : 데이터를 보내는 상대와 자신을 특정하는 데이터
  - 유니캐스트 주소 : 1대1 (유일)
  - 브로드캐스트 주소 : 전원(2계층은 세그먼트내의 모든 기기)
  - 멀티캐스트 주소 : 1대 지정된 다수 (그룹 주소)
- 각각의 기기는 **유니캐스트 주소** 적어도 한개 갖고 있다
- 유니캐스트 주소는 **유일**하다
- 라우터처럼 복수의 인터페이스를 가진 기기는 인터페이스마다 유니캐스트 주소를 갖는다
- 멀티캐스트 그룹에 속한 기기는 본인의 유니캐스트 주소와 멀티캐스트 주소 2개를 갖고있다
- 어드레싱(addressing) : 주소를 어떻게 사용하고 배정할지

## MAC 주소(Media Access Control)

- MAC 주소 : 이더넷에서 사용되는 주소, 이 주소는 인터페이스에 지정된 고정 주소이다
- 48비트 값으로 4비트마다 16진수로 고쳐쓴다 ( ex. 00-0D-61-76-FF-6D)
  - 벤더코드: 첫 24비트, 인터페이스를 제조한 메이커의 번호
  - 후반 24비트는 제조한 메이커 붙인 벤더 할다 코드 (몇번째 제조)

# 이더넷

- LAN에서 사용하는 2계층 프로토콜
- 이더넷은 이더넷 헤더와 이더넷 트레일러를 데이터그램(패킷)에 붙여 이더넷 프레임으로 캡슐화
- 프레임
  - 이더넷 헤더 (14바이트)
  - 페이로드(3계층의 PDU = 패킷, 데이터 그램)
  - 이더넷 트레일러 (4바이트)

## 이더넷 헤더

- 수신처 MAC 주소: 48비트
- 송신처 MAC 주소: 48비트
- 타입 : 16비트 : 페이로드에서 전송하는 데이터(3계층 PDU)의 종류를 특정하는 값 (IP프로토콜은 16진수로 0800)

## 이더넷 트레일러

- FCS(Frame Check Sequence): 32비트 : 에러체크용 비트열
- 신호가 전송되는 동안에 문제가 생겨서 정확하게 읽을 수없게 되거나, 0과 1을 서로 바꿔 읽는 경우 에러 체크
- 기본적으로 통신도중에는 에러를 고칠수 없다 (허밍부호 같은 에러체크 코드를 쓰면 가능은 함, 그러나 허밍부호도 복수의 비트 에러는 못 고친다)
- 에러 발생시 해당 프레임은 파기, 파기했다는 사실은 송신측에 알리지 않는다

## 이더넷 동작

- 1계층의 2가지 문제점
  1. 플러딩에 의해 허브에 연결되어 있는 모든기기에 신호가 도달 (멀티액세스 네트워크에서)
  2. 충돌이 발생
- 모든기기에 신호가 도달
  - 이더넷에서는 **수신한 프레임의 수신처 MAC 주소를 보고 자기에게 온것외의 다른 프레임 파기**
  - 멀티캐스트 : 멀티캐스트 주소에 그룹이 번호가 있어 그 기준으로 파기
  - 브로드 캐스트: 전체 수신이므로 반드시 수신
- 충돌
  - **CSMA/CD**(Carrier Sense Multiple Access/Collision Detection): 신호를 보내는 타이밍을 겹치지 않도록 비켜나게하여 가능하면 충돌이 일어나지 않도록하는 **액세스 제어**
  - 액세스 제어란 인터페이스에 연결되어 있는 케이블에 신호를 보내는 **액세스**를 **제어**한다는 것을 의미
  - CSMA/CD
    - CS(신호 감지) : 누군가가 송신중이라면 송신하지 않는다
    - MA(다중 액세스) : 아무도 송신하고 있지 않으면 송신할수 있다
    - CD(충돌 검사) : 송신 후에 충돌이 일어나면 다시 재수행한다
  - CSMA/CD는 2대 이상이 동시에 아무도 송신하고 있지 않다고 판단하면 동시 송신이 일어나 충돌이 발생한다
  - 완벽하지 않은 방법이다 => 스위치로 해결

## CSMA/CD 과정

1. 송신을 희망한다(충돌 카운터 0으로 초기화)
2. 누군가 송신중인가(CS) => 예 => 조금 있다 다시 2로
3. 임의시간 대기(MA)
4. 아무도 송신하지 않으면 송신 => 누군가 송신중이다 => 조금 있다 다시 2로
5. 충돌이 발생했다(CD) => 8로
6. 연속해서 데이터를 송신한다? => 1로
7. 종료 (일반적인 상황은 여기서 끝)
8. 계속해서 JAM신호(다른 기기에 충돌을 알리고, 도중까지 수신한 프레임 파기하도록 전함)를 송신
9. 충돌 카운터 + 1 시킨다
10. 충돌 카운터가 16이상 => 송신 중지 (충돌이 너무 많음)
11. 16미만 랜덤한 시간 대기후 다시 2로

# 스위치 (Switch)

- 스위치, 스위칭 허브, 이더넷 스위치, 2계층 스위치라고도 불린다
- 스위치는 **수신한 프레임을 따로 따로 보낼수 있도록 처리해서 충돌을 막는** 기기이다
- **MAC 주소 필터링**과 **버퍼링**을 사용
- CSMA/CA는 충돌을 막는것이 아닌 일어나기 어렵게 만드는것 까지만 가능
- 충돌도메인내에 컴퓨터가 많아지면 CSMA/CD로는 효율이 아주 나쁜 상태가 된다
- 충돌 해결은 2가지
  - 충돌이 일어나지 않게 타이밍을 조절 => CSMA/CD
  - 신호가 지나는 길 자체를 안 겹치게 나눈다 => 스위치
- 스위치도 허브와 마찬가지로 복수의 포트를 갖고 있다
- LAN에서 쓰는 UTP케이블이나 광파이버 케이블은 **송신 신호**와 **수신 신호**가 나뉘어져 있다
- 따라서 케이블상에서는 송신 신호와 수신 신호가 동시에 지나가도 충돌이 발생하지 않는다
- 충돌은 **허브**에서만 발생, 허브는 2개 이상의 신호를 동시에 수신하면 나누어 보낼수 없음
- 즉 케이블은 냅두고, 허브만 스위치로 교체하면 문제 해결
- 충돌 도메인은 스위치에 의해 분할된다
- 스위치를 사용해 전이중 통신을 하는것을 **전이중 이더넷**이라고 한다
- 최근에 이더넷은 대부분 스위치를 사용한 전이중 이더넷

## MAC 주소 필터링

- 학습
  - 수신한 프레임의 송신처 MAC 주소를 기록한다, 즉 포트와 MAC 주소를 연관시킨다
  - MAC 주소 어드레스 테이블에 표를 만들어 둔다
- 스위칭
  - 프레임을 수신하 스위치는 프레임의 수신처 MAC 주소를 보고 그 MAC 주소가 있는 포트만 프레임 전송
  - 수신처가 다른 프레임이 동시에 도달해도, 플러딩이 없으니 충돌 발생 X
  - 만약 어드레스 테이블에 없는 학습 안된 MAC주소가 도달할 경우, 필터링이 불가능하므로 플러딩
  - 당연하지만 브로드캐스트가 수신처인 프레임도 플러딩
  - 멀티캐스트는 플러딩을 하거나, **IGMP 스누핑**을 써서 필터링 가능

## 버퍼링

- MAC 주소 테이블을 이용하면 수신처가 다른 프레임은 충돌 하지 않고 각각 보낼수 있게됨
- 그러나 수신처가 같은 프레임이 동시에 도달하면 여전히 충돌 가능성이 있음
- **버퍼**를 이용한 **버퍼링**을 사용, 버퍼는 일시적으로 데이터를 기억할수 있는 메모리다
- 충돌할것 같은 프레임을 버퍼에 일시적으로 저장 후, 송신을 먼저 보내고 해당 송신이 끝나면 저장해두었던 프레임을 송신한다
- 중요한 것은 **버퍼의 용량**
- 버퍼의 용량이 부족할 정도로 프레임이 도달한다면, **백 프레셔**(Back Pressure) 또는 **IEEE802.3x** 규격을 사용해서 송신을 중단시킴

## 백프레셔

0. 반이중(Half-duplex) 환경에서 사용 (허브를 사용한 이더넷, CSMA/CD, 허브 스위치 같이 쓰는 케스케이드 네트워크)
1. 스위치에서 버퍼 용량 초과 직전
2. 컴퓨터는 계속 송신
3. 스위치가 JAM 신호 (충돌을 알림)를 컴퓨터로 송신
4. 송신 컴퓨터에서 충돌이 일어났다고 판단해 송신 중지

## IEEE802.3x

0. 전이중(Full-duplex) 환경에서 사용 (스위치를 사용한 이더넷)
1. 스위치에서 버퍼 용량 초과직전
2. 컴퓨터는 계속 송신
3. PAUSE 프레임이라는 IEEE802.3x 전용 프레임을 송신
4. PAUSE 프레임에 의해 송신 컴퓨터는 송신 일시 중지

## IGMP 스누핑

IGMP 스누핑은 네트워크 스위치에서 멀티캐스트 그룹을 식별하는 데 사용하는 방법입니다. 멀티캐스트 그룹이란 모두 동일한 네트워크 트래픽을 수신하는 컴퓨터 또는 장치의 그룹입니다. IGMP 스누핑을 통해 스위치는 네트워크의 올바른 장치로 패킷을 전달할 수 있습니다.

인터넷 그룹 관리 프로토콜(IGMP)은 여러 장치가 하나의 IP 주소를 공유하여 모두 동일한 데이터를 수신할 수 있도록 하는 네트워크 계층 프로토콜입니다.네트워크 장치에서는 IGMP를 사용하여 멀티캐스팅 그룹에 가입하고 탈퇴하며, 각 멀티캐스팅 그룹에서는 IP 주소를 공유합니다.

그러나 대부분의 네트워크 스위치는 네트워크 계층 프로토콜을 처리하지 않으므로 멀티캐스팅 그룹에 가입한 장치를 확인할 수 없습니다. IGMP 스누핑은 이 문제를 해결하는 방법입니다. 기술적으로 OSI 모델의 다른 계층에 속하더라도 IGMP 메시지를 "스누핑"할 수 있습니다. IGMP 스누핑은 IGMP 프로토콜의 기능이 아니라 일부 네트워크 스위치에 내장된 적응 기능입니다.

네트워킹 프로토콜 및 장비는 속한 계층에 따라 부분적으로 정의됩니다. 네트워킹 장비의 기능은 장비가 상호 작용할 수 있는 계층에 의해 제한됩니다. 계층 2 스위치에서는 계층 3 프로토콜이 처리되지 않습니다.

IGMP 스누핑은 이 제한을 우회합니다. 계층 2 스위치에서 계층 3 IGMP 트래픽을 관찰하고 멀티캐스트 IP주소에 대한 멀티캐스트 MAC주소를 MAC 테이블에 등록한다
