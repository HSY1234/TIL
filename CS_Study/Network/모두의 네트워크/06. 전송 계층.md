# 전송 계층 (Transport layer)

- 전송 계층은 **목적지에 신뢰할 수 있는 데이터를 전달**하기 위해 필요
- 전송 계층은 **오류를 점검하는 기능**이 있다
- 전송 계층은 **전송된 데이터의 목적지가 어떤 애플리케이션인 식별하는 기능**이 있다
- 물리계층, 데이터 링크 계층, 네트워크 계층 3계층이 있으면 목적지에 데이터를 보내는 것이 가능
- 하지만 데이터가 손상되거나 유실되더라도 상위 3계층은 아무것도 해주지 않는다
- 신뢰할수 있는 데이터를 순차적으로 전달하는 역할을 하므로 상위 계층들이 데이터 전달의 유효성이나 효율성을 신경쓰지 않도록 한다
- 대표 장치: L4 스위치

## 연결형 통신(connection-oriented) & 비연결형 통신(connectionless)

- 신뢰성/ 정확성 (데이터를 문제없이 전달)=> 연결형 통신
- 효율성 (데이터를 빠르게 전달)=> 비연결형 통신
- 연결형 통신은 상대와 확인해 가면서 통신하는 방식이고(여러번 왔다갔다), 비연결형 통신은 확인하지 않고 일방적으로 보낸다(한번)
- 대부분은 정확한 데이터를 위해 연결형 통신을 사용
- 비연결형 통신은 보통 동영상처럼 일부가 유실되어도 문제없는 경우 사용
- 대표적인 연결형 통신 프로토콜 TCP
- 대표적인 비연결형 통신 프로토콜 UDP

# TCP (Transmission Control Protocol, 전송 제어 프로토콜)

- 연결형 통신 프로토콜의 한 종류
- TCP는 전송 계층의 프토로콜의 일종으로 **TCP 헤더**를 붙인다
- TCP헤더가 붙은 데이터를 **세그먼트**(segment)라고 한다
- TCP 헤더 구조
  - 출발지 포트 번호 (16비트)
  - 목적지 포트 번호 (16비트)
  - 일련번호 (32비트)
  - 확인 응답 번호(32비트)
  - 헤더 길이 (4비트)
  - 예약 영역 (6비트)
  - 코드 비트 (6비트)
  - 윈도우 크기 (16비트)
  - 체크섬 (16비트)
  - 긴급 포인터 (16비트)
  - 옵션
- TCP는 연결형 통신이기 때문에 데이터 전송 전에 **연결**(connection)이라는 **가상의 독점 통신로를 확보**해야 한다. 연결을 확립후 데이터 전송 가능
- TCP의 코드 비트 (각 1비트)
  - URG
  - ACK
  - PSH
  - RST
  - SYN
  - FIN
- 각 코드 비트의 초깃값은 0이고 비트가 활성화되면 1
- 연결을 위해서는 ACK, SYN이 필요하다
- **SYN**은 연결 요청
- **ACK**은 확인 응답
- **FIN**은 연결 종료

## 3-way 핸드셰이크 (3-way handshake)

- 연결을 확립하기위한 TCP의 과정, 마치 상대방을 확인하고 악수를 하는것 같아서 이름을 붙였다
- 신뢰할 수 있는 연결을 하려면 데이터를 전송하기 전에 패킷을 교환하는데, 확인을 세번한다
- 과정
  1. 통신을 하려면 상대 컴퓨터의 허가를 받기위해 연결 확립 허가인 SYN 요청을 보낸다
  2. 상대가 보낸 요청을 받은후 허가하겠다는 응답을 회신하기위해 연결 확립 응답 ACK를 보낸다. 이때 자신도 데이터 전송 허가를 받기위한 연결 확립 요청 SYN을 같이 보낸다
  3. 상대가 다시 보낸 요청을 받은 컴퓨터는 연결을 허가한다는 응답으로 연결 확립 응담 ACK를 보낸다
- 과정을 비트로 보기
  1. SYN을 1로 해서 요청을 보냄
  2. 요청 수락을 위해 ACK를 1로 만들고, 이쪽에서도 요청을 위해 SYN도 1로해서 응답을 보냄
  3. 요청 수락을 확인했고, 이쪽도 요청 수락했다는 뜻으로 ACK를 1로 해서 보냄

## 4-way 핸드셰이크 (4-way handshake)

- 연결을 종료하기 위한 TCP의 과정
- 과정
  1. 컴퓨터 1이 연결 종료 요청 FIN을 컴퓨터 2에게 보낸다
  2. 컴퓨터 2에서 컴퓨터 1로 연결 종료 응답 ACK를 반환한다
  3. 컴퓨터 2에서 컴퓨터 1로 연결 종료 요청 FIN을 보낸다
  4. 컴퓨터 1에서 컴퓨터 2로 연결 종료 응답 ACK를 반환한다
- 과정을 비트로
  1. FIN을 1로 보내기
  2. ACK 1로 답장
  3. FIN을 1로 보내기
  4. ACK 1로 답장

## 일련번호 (sequence number)와 확인 응답 번호(acknowledgement number)의 구조

- 3 way 핸드셰이크로 연결 확립 이후, 실제 데이터를 보내거나 상대방이 받을때 **일련번호**와 **확인 응답 번호**를 사용
- 일련번호: 송신측에서 수신 측에 이 데이터가 **몇 번쨰 데이터**인지 알려주는 역할
- 확인 응답 번호: 수신 측에서 **몇 번째 데이터**를 수신했는지 송신 측에 알려주는 역할
- 확인 응답 번호는 다음 번호의 데이터를 요청하는데도 사용된다. 10번 데이터를 수신했으면 11번 데이터를 송신측에 요청 이를 **확인 응답**이라고 한다
- 일련번호 3001번 200바이트 데이터를 보내는 과정
  1. 3-way 핸드셰이크로 연결 수립이 이루어 질때 일련번호와 확인 응답 번호 결정
  2. 컴퓨터 1은 컴퓨터 2로 200바이트 데이터 전송 (일련번호 3001 , 확인 응답 번호 4001)
  3. 컴퓨터2는 200바이트 수신하고 다음 수신하고자 하는 데이터 번호를 확인 응답 번호에 넣는다 (일련번호 4001, 확인 응답 번호 3201)
  4. 컴퓨터1은 컴퓨터2로 3201번부터 200바이트 데이터를 전송 (일련번호 3201, 확인 응답 번호 4001)
  5. 컴퓨터2는 200바이트 수신하고 다음에 수신하고자 하는 데이터 번호를 확인응답번호에 넣는다
     (일련번호 4001, 확인 응답 번호 3401)
  6. 2~5과정 데이터 전송 완료까지 반복
- 데이터가 항상 올바르게 전달되는 것은 아니므로 일련번호와 확인 응답 번호를 사용해서 데이터가 손상되거나 유실된 경우에 데이터를 재전송하게 된다. 이것을 **재전송 제어**라고 한다
- 재전송 제어는 데이터 전송중 오류가 발생하면 일정 시간동안 대기후에 재전송한다

## 윈도우 크기

- 위처럼 세그먼트 하나를 보낼 때마다 확인 응답을 한번 반환하는 통신은 효율이 낮음
- 매번 응답하는 대신 세그먼트를 연속해서 보내고 난 다음 확인 응답을 반환하면 효율이 높음
- 받은 세그먼트를 일시적으로 보관하는 장소를 **버퍼**라고 한다
- 수신측으로 대량으로 데이터가 전송되면 보관하지 못하고 넘쳐 버림. 이를 **오버플로**라고 함
- 오버플로가 발생하지 않도록 **버퍼의 한계 크기**를 알고 있어야한다
- TCP 헤더의 **윈도우 크기**(window size)값에 해당
- 윈도우의 크기의 초기값은 3-way handshake에서 판단
- SYN으로 요청을 보낼때 윈도우 한계 크기를 같이 보내 체크
- 버퍼의 사이즈를 확인했다면 오버플로우가 일어나지 않게 세그먼트 송신을 확인 응답이 오기전에 한꺼번에 보낼수 있다
- 이전
  1. 세그먼트 송신
  2. 확인 응답
  3. 세그먼트 송신
  4. 확인 응답
  5. 반복
- 버퍼를 이용
  1. 세그먼트 송신
  2. 세그먼트 송신
  3. 세그먼트 송신
  4. 확인 응답
  5. 확인 응답
  6. 확인 응답
  7. 세그먼트 송신
  8. 세그먼트 송신
  9. 세그먼트 송신
  10. 확인 응답
  11. 확인 응답
  12. 확인 응답

# 포트 번호 (port nubmer)

- 연결 확립, 재전송 제어, 윈도우 제어는 데이터를 정확하게 전달하기 위한 기법
- TCP의 다른 목적인 목적지가 어떤 애플리케이션인지 구분하는 역할은 **포트**를 사용!
- TCP헤더의 **출발지 포트번호**(source port number)와 **목적지 포트 번호**(destination port number)를 사용한다
- 출발지 포트번호는 해당 어플리케이션이 다시 응답을 받을 포트번호이기도 하다
- 포트번호는 0~65535번을 이용
- 포트번호 0~1023번 포트는 주요 프로토콜이 사용하도록 예악되어 있다 = **잘알려진 포트** (well-known ports)
- 포트번호 1024~ 49151번은 **등록된 포트**(registered ports), 사용자가 직접 등록해서 사용할수 있다+
- 포트번호 49152~65535번은 **동적 포트**(dynamic port) 수시로 변경되는 포트 인터넷이나 시스템에서 동적으로 할당받는 포트
- well known ports 예시
  | 애플리케이션 | 포트 번호|
  |------------|-----------|
  | SSH | 22 |
  | SMTP | 25 |
  | DNS | 53 |
  | HTTP | 80 |
  | POP3 | 110 |
  | HTTPS | 443 |
- 1024은 예약되어 있지 않지만 사용하지 않는 포트
- 1025이상은 **랜덤 포트**로 클라이언트 측의 송신 포트로 이용
- 애플리케이션은 각각 포트 번호가 있어서 다른 애플리케이션과 구분된다.
- 데이터를 전송할때는 IP 주소가 필요하지만, 어떤 애플리케이션이 사용하는지 구분하려면 TCP는 포트번호가 필요하다
- 웹브라우저는 접속할때 임의의 포트가 **자동으로 할당**되어 서버측은 포트를 정해둬야 하지만, 클라이언트 측은 정하지 않아도 된다

# UDP (User Datagram Protocol)

- 정보를 서로 주고 받을때 보내는 쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜
- UDP는 TCP와 달리 비연결형 통신이라서 3-way 핸드셰이크처럼 데이터를 정확히 전달하기 위한 작업을 수행하지 않음
- UDP는 효율성을 중요하게 여기는 프로토콜, 데이터를 효율적으로 빠르게 보내는 것이 목적
- 주로 동영상에서 사용
- **UDP 헤더**가 붙은 데이터를 **UDP 데이터 그램**이라고 한다
- UDP 헤더 구조
  - 출발지 포트 번호 (16비트)
  - 목적지 포트 번호 (16비트)
  - 길이 (16비트)
  - 체크섬 (16비트)
- UDP는 TCP와 달리 확인작업 없이 계속 송신을 보낸다
- UDP는 브로드캐스트가 가능
- TCP는 3-way 핸드셰이크와 같이 확인 응답을 하나씩 보내야하기 떄문에 브로드캐스트 같은 불특정 다수에게 보내는 통신은 적합하지 않음
