# 페이지 교체 & 프레임 할당

- 가상 메모리를 통해 작은 물리 메모리보다 큰 프로세스를 실행 가능
- 이를 위해선 불필요한 페이지를 선별하여 보조 기억장치에 보내야하고
- 새로운 프로세스에게 적절한 수의 프레임을 할당할수 있게 해야함
- 요구 페이징
- 페이지 교체 알고리즘
- 프레임 할당

# 요구 페이징 (demand paging)

- 처음부터 프로세스 전부를 적재하지 않고, 필요한 페이지만 메모리에 적재하는 방법
- 과정
  1. CPU가 특정 페이지에 접근하는 명령어를 실행
  2. 해당 페이지가 현재 메모리에 있다면(유효비트 1) CPU는 적재된 프레임에 접근
  3. 해당 페이지가 현재 메모리에 없다면(유효비트 0) 페이지 폴트! 발생
  4. 페이지 폴트 처리 루틴 실행으로 해당 페이지를 메모리에 적재후 유효비트 1로 변경
  5. 다시 1번으로
- 이 방식은 아무런 페이지도 메모리에 적재하지 않았을때도 실행 가능
- 즉 첫 명령어 실행부터 페이지 폴트 발생, 실행할때 높은 확률로 페이지 폴트가 일어나다, 어느 정도 적재되면 점점 페이지 폴트 발생률 하락
- 이를 **순수 요구 페이징**(pure demande paging) 기법이라고 한다
- 요구페이징을 안정적으로 하기 위해선 두가지를 해결해야한다.
- **페이지 교체** : 어떤 페이지를 내보내야 할까? => 페이지 교체 알고리즘
- **프레임 할당** : 각 프로세스에게 프레임을 각각 몇개씩 줘야할까?
- **페이지 폴트**를 최대한 낮춰보자!

# 페이지 교체 알고리즘 (Page Replacement Algorithm)

- 좋은 페이지 교체 알고리즘 = 페이지 폴트가 적게 일어나는 알고리즘
- 앞으로 쓰거나 & 자주 쓸 페이지를 스왑아웃하지 않는게 핵심
- 페이지 교체 알고리즘의 핵심은 **페이지 폴트 횟수**
- **페이지 참조열**(page reference string)를 이용해 페이지 폴트 횟수를 알수있다
- 페이지 참조열 : CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열(string)
  - `2 2 2 3 5 5 5 3 3 7` 을 (페이지열)
  - `2 3 5 3 7` 로 변경 (페이지 참조열)
- 중복을 제거하는 이유는 중복된 페이지를 연속해서 참조하는것은 페이지 폴트를 발생시키지 않기 때문
- 연속된 페이지를 참조하는건 페이지 폴트 발생 X, 오직 페이지 폴트 발생 횟수만이 관건
- 페이지 교체 알고리즘은 매우 많음

## FIFO 페이지 교체 알고리즘(First-In-First-Out Page Replacement Algorithm)

- 페이지 폴트 발생시 메모리에 먼저 올라온 페이지를 먼저 내보냄
- 예시) 프레임은 3개
  - 2 3 1 3 5 2 3 4 2 3
  - 2, 3 ,1 적재
  - 3 통과
  - 5 페이지 폴트
  - 2 빼고 5 적재
  - 2 페이지 폴트
  - 3 빼고 2 적재
  - 3 페이지 폴트
  - 1 빼고 3 적재
  - ....
  - 페이지 폴트 4번!
- 구현은 쉬우나 좋은 알고리즘 X
  - 실행 초기에 적재된 페이지속 프로그램이 잠깐 실행되고 이후에 안쓰는 경우는 유리
  - 초기에 올라와서 실행내내 쓰이는 페이지는 계속 나가게 된다

## FIFO 응용 - 2차 기회 페이지 교체 알고리즘 (second chance page replacement algorithm)

- FIFO의 변형, 기회를 한번 더 준다
- 가장 오래되어 내보낼 페이지의 참조비트가 1이면 0으로 바꾼다, 그리고 적재 시간을 현재 시간으로 변경
- 참조 비트 1은 한번 접근했으니 기회를 한번 더 줌
- 참조 비트 0은 가장 오래된 페이지면서 사용하지 않은 페이지이니 바로 보조 기억장치로 보냄

## 최적 페이지 교체 알고리즘 (optimal page replacement algorithm)

- CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘
- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
- 가장 낮은 페이지 폴트를 보여주는 **이상적인 알고리즘**
- 실제 구현은 불가능! 앞으로 **가장 오랫동안 사용되지 않을 페이지**를 예측하는건 불가능하다 = 사실상 미래 예측
- 페이지 교체 알고리즘의 효율 이론상 성능을 평가하기위한 **이상적인 알고리즘**
- 즉 최적 페이지 교체 알고리즘은 페이지폴트 횟수의 하한선을 보여준다
- 예시) 프레임은 3개
  - 2 3 1 3 5 2 3 4 2 3
  - 페이지 폴트 2번!

## LRU 페이지 교체 알고리즘(Least Recently Used Page Replacement Algorithm)

- 가장 오랫동안 **사용되지 않은 페이지**를 교체하는 알고리즘
- 가장 오랫동안 사용되지 않은 페이지는 앞으로도 쓸 확률이 낮다는 아이디어가 토대
- 예시) 프레임은 3개
  - 2 3 1 3 5 2 3 4 2 3
  - 페이지 폴트 3번!

# 프레임 할당

- 페이지 폴트의 원인은 페이지 교체 알고리즘에만 있는게 아니다
- 프로세스가 사용할수 있는 **프레임 수**가 적으면 페이지 폴트는 자주 발생!
- 만약 극단적으로 프레임이 한개면, 다른 페이지를 참조할때마다 페이지 폴트가 일어남
- 프레임수가 많으면 페이지 폴트 수는 저절로 줄어든다
- 프레임수가 적다면, CPU는 실제 실행보다 페이지 교체에 더 많은 자원을 쓰게 됨
- 프로세스가 실제 실행되는 시간보다, 페이징에 더 많은 시간을 사용하여 성능이 저하되는 문제를 **스레싱**(thrashing)이라고 함

# 스레싱(thrashing)

- 스레싱을 그래프로 표현
- 세로는 CPU 이용률 = CPU가 얼마나 프로세스를 실제로 실행하고 있는가 (프로세스가 아닌 페이지교체등이 많아지면 낮아짐)
- 가로는 멀티프로그램의 정도(degree of multiprogramming) = 메모리에 동시에 실행되는 프로세스 수
- 처음에는 멀티프로그램밍 정도가 증가하면 CPU 이용률이 점점 올라간다
- 그러나 필요 이상으로 프로세스 수를 늘리면, 프로세스당 프레임수가 저하되어 페이지 폴트 증가, 스레싱 현상 발생
- 스레싱의 근본 원인은 프로세스별 최소한의 프레임수가 보장되지 않기 때문
- 즉 프로세스별로 적당한 프레임이 할당 되어야한다

## 프레임 할당 방식

- **정적 할당 방식**: 프로세스 실행과정은 고려하지 않고, 단순히 프로세스의 크기만 고려해서 할당
  - **균등할당**(equal allocation) : 모든 프로세스에게 균등하게 프레임 배분
    - 300개의 프레임을 3개의 프로세스에게 각각 100개씩
  - **비례할당**(proportional allocation) : 프로세스 크기가 크면 프레임 많이, 적으면 적게 나눠줌
    - 프로세스의 크기가 커도 많은 프레임이 필요하지 않거나, 프로세스가 작아도 많은 프레임이 실행중에 필요한 경우도 존재해서 완벽한 방식은 아님
- **동적 할당 방식**: 프로세스의 실행을 보고 할당할 프레임수를 결정
  - **작업 집합 모델** (working set model) : 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억해 사용이 빈번한 페이지의 교체를 막음
    - 참조 지역성에 의해 CPU는 비슷한 지역을 집중적으로 참조 = CPU가 특정 시간 동안 참조한 페이지 개수만큼 프레임을 할당하면 페이지 교체는 줄어들것이라는 아이디어
    - 예) 3초동안 7개라면 => 7개, 3초동안 20개면 => 20개
    - **작업 집합**(working set) : 실행 중인 프로세스가 일정 시간동안 참조한 페이지의 집합
      - 프로세스가 참조한 페이지
      - 일정 시간 간격
      - 두가지를 정해야 작업 집합을 정할수 있다
  - **페이지 폴트 빈도** (PFF: page-Fault Frequency) : 페이지 폴트 빈도를 기반으로 한 프레임 할당
    - 페이지 폴트율이 너무 높다면 => 프로세스의 보유 프레임이 너무 적다
    - 페이지 폴트율이 너무 낮으면 => 프로세스의 보유 프레임이 너무 많다
    - 프로세스의 할당 프레임의 상한, 하한을 미리 설정해놓고 기준을 넘으면 프레임을 할당해주거나 회수한다
