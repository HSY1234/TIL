# 전송계층

- 1~3계층까지의 역할은 **수신처 컴퓨터에 데이터를 보내는 것**
  - 1계층 : 케이블이 연결되어 있는 상대에 대한 신호전달 = 케이블
  - 2계층 : 신호를 주고 받을수 있는 상태의 세그먼트 내에서 어떻게 데이터 송수신을 할지 = MAC주소, 스위치
  - 3계층 : 세그먼트(네트워크) 사이에 어떻게 데이터 송수신을 할지 = IP주소, 라우터
- 4계층 이상의 상위 계층 **전달할, 전달한 데이터에 대해 필요한 처리**를 한다
- 전달하기 전, 전달된 후에 데이터 통신을 위한 처리를 진행
- 4계층은 **신뢰성이 높은 데이터 전송을 하기 위한 처리**를 한다
- 3계층까지는 데이터 전송만 생각하지, 수신처가 존재하지 않거나, 데이터가 도중에 손실됐거나, 에러에 의해 파기되는 등 문제들은 생각하지 않는다
- 4계층에서는 통신에 필요한 처리를 TCP/IP 프로토콜 군에서 **TCP**(Transmission Control Protocol)나 **UDP**(User Datagram Protocol) 프로토콜을 사용한다
- TCP, UDP는 동시에 사용되지 않고 둘중 하나가 선택되어 사용된다

## 전송계층의 역할

- **에러복구**
  - 데이터를 수신하면, 송신처에게 수신한것을 통지한다(**확인 응답**)
  - 송신처는 확인 응답을 받아 수신처가 데이터를 받은것을 확인
  - 도중에 에러 발생으로 데이터가 없어져서 확인응답이 돌아오지 않은경우
  - 데이터를 다시보내 에러를 복구한다
- **흐름 제어** : 처리 능력을 넘어선 정보를 받았을때, 다 처리할수 없어서 파기하는 경우를 방지(오버 플로우 방지)
  - 수신처에 데이터를 보내면, 수신처는 데이터를 받아서 그것을 일시적으로 모아둔다
  - 준비되는대로 처리
  - 처리가 늦어지거나 송신 속도나 간격이 빠른 경우 데이터가 점점 쌓이기 때문에 모아둘수 없어 파기하게 된다(오버플로우)
  - 오버플로우를 방지하기 위해 수신측은 확인응답 때에 모아둘 수 있는 데이터 양을 송신처에 통지하여, 송신양을 가감하게 하거나 송신을 일시적으로 중단시킨다 (**윈도우 제어**)
- **애플리케이션 식별** : 통신을 통해 데이터를 주고 받는건 컴퓨터가 아닌 **애플리케이션**이다
  - 송신 & 수신한 데이터가 어느 애플리케이션이 송신& 수신한 데이터인지 결정해야한다
  - 이를 위해 **포트 번호**(Port Number)라는것이 부여된다
  - 애플리케이션은 내부적으로 포트에 의해 통신기능과 접속되어 있다
  - 데이터를 넣고 꺼내는 가상의 출입구라고 생각

# TCP

- TCP에서 애플리케이션 간의 데이터 송수신을 할수 있다

## 커넥션

- 커넥션 : 애플리케이션 간의 송수신을 하는 **데이터의 길**
- 커넥션은 TCP에서 만들어진 **가상적인 통신로**, 미리 전용 통신로를 만들어 확실하게 데이터 전달하는것이 목표
- 3계층까지의 역할로 데이터를 전달할수 있는데 커넥션을 만드는 이유는?
  - 상대가 존재하지 않으면 보내는게 의미가? => 3계층까지는 존재하는지 안하는지 확인 기능 X (ICMP가 있긴 하다)
  - 상대가 존재하지만 수신할 준비가 안되어 있다
  - 수신은 가능한데 처리 능력을 넘어서서 데이터 처리가 불가능하다
  - 등등 여러 이유로 도달한 데이터를 제대로 처리 불가능
- **컴퓨터까지 데이터가 도달한다** 와 **데이터를 확실히 주고받았다**는 별개의 문제다!
- 3계층은 데이터를 확실히 주고 받는것을 보장하지 않는다
- 커넥션이란 **데이터 전송을 시작하기 전에 미리 확인을 주고 받아 두는 것**, 상대에게 확실하게 전달한것을 미리 확인
- 실제 케이블이 어떻게 연결되고(1, 2계층), 어느 라우터를 통해 수신처까지 도달할 것인지(3계층)과는 관계 없이 **실제 통신로**가 아닌 **가상의 통신로**를 생긴다고 여긴다. 이 가상의 통신로를 만들어 내는 일련의 과정을 **커넥션 확립**이라고 한다
- **TCP 헤더**는 기본적으로 20바이트 + 알파, TCP 헤더 6비트의 제어비트(플래그)는 그 TCP 데이터의 의미를 표현

## 커넥션 확립

- 커넥션 확립을 위해서는 **상대가 데이터 전송을 허가**해야한다
- **통신로 확보하기 위해 상대에게 데이터 전송 허가 요청**을 보낸다
- 요청 받은 상대는 **그것에 대한 허가를 송신처에게 보낸다**
- **이 과정을 통해 바르게 전달된 것을 확인할 수 있다**
- 위 과정이 끝나면 **수신처 측이 송신처에게 데이터 전송 허가 요청**을 보낸다
- 송신처도 데이터 전송 허가를 보내고 **쌍방향의 통로가 확보**
- 첫과정만 하면 커넥션 확립이 끝난것이 아닌가?
  - A -> B만 허가 되었지 (요청에 대한 응답만 보냄)
  - B -> A는 허가가 된 상황이 아니기 떄문
- 이 3번 주고 받는 과정이 3방향 악수같아서 **3-way handshake**라 부른다
- 3 way handshake
  1. 송신 -> 수신 : 커넥션 확립요청 (TCP 헤더의 SYN의 비트 1)
  2. 수신 -> 송신 : 커넥션 확립응답 + 확립 요청 (TCP헤더의 SYN, ACK 비트 1)
  3. 송신 -> 수신 : 커넥션 확립 응답 (TCP 헤더의 ACK 비트 1)
- 4-way 핸드셰이크 (4-way handshake)

  1. 컴퓨터 1이 연결 종료 요청 FIN을 컴퓨터 2에게 보낸다
  2. 컴퓨터 2에서 컴퓨터 1로 연결 종료 응답 ACK를 반환한다
  3. 컴퓨터 2에서 컴퓨터 1로 연결 종료 요청 FIN을 보낸다
  4. 컴퓨터 1에서 컴퓨터 2로 연결 종료 응답 ACK를 반환한다

- 과정을 비트로
  1. FIN을 1로 보내기
  2. ACK 1로 답장
  3. FIN을 1로 보내기
  4. ACK 1로 답장

## 세그먼트 분할

- TCP는 애플리케이션으로 부터 받은 데이터를 세그먼트로 캡슐화
- 캡슐화할때 한개의 데이터를 **MSS**(Max Segment Size)로 분할하는데, 한개의 데이터가 복수의 세그먼트가 된다
- 그리고 **각각의 세그먼트에 번호를 부여**하고 이것을 **시퀀스 번호**라고 한다 (TCP 헤더에 있다)

## 에러 복구

- TCP에서는 시퀀스 번호를 사용해 에러를 복구한다
- 세그먼트를 수신하면, **수신한 것을 송신처에 전달** = **확인응답**
- TCP 헤더의 시퀀스 번호와 확인 응답 번호를 이용한다
  - 데이터 송신 시에는 시퀀스 번호
  - 확인 응답에는 확인응답 번호
- 시퀀스 번호는 데이터의 앞 부분에 있는 옥텟 번호, 확인 응답번호는 다음에 받고 싶은 데이터의 선두 옥텟 번호
- 즉 확인 응답에는 **다음에 받을 예정의 데이터 번호**를 전달하는 역할이 있다
- 수신측이 어디까지 데이터를 받았는지 알수있다
- 에러가 발생해서 상대에게 데이터가 도달하지 않거나, 확인 응답이 도달하지 않았다면 일정시간 대기후 **재전송**
- 기다리는 시간은 **RTT**(Round Trip Time)는 보낸 데이터가 확인 응답이 돌아올때 까지 걸린 시간으로 계산
- RTT는 초기값을 설정후, 확인응답이 돌아오는데 걸린 시간을 동적으로 변경한다
  - 빠른 회선은 시간이 줄것이고
  - 느린 회선은 시간이 늘것이다

## 윈도우 제어

- 세그먼트 송신 -> 확인 응답은 효율이 낮은 방법이다 (확인 응답이 올때까지 전송 불가)
- **복수의 세그먼트 전송** -> **확인 응답**으로 형태 변경 -> 효율 상승
- 복수의 세그먼트 전송을 정확 확실하게 보내기 위해 **윈도우 제어**를 한다
- 윈도우 제어에는 수신한 데이터를 **일시적 으로 보관**하는 **버퍼**(buffer)가 존재
- TCP는 오버플로를 막기위해 **상대에게 어느정도 버퍼량을 가지고 있는지 알려줄 필요가 있다**
- 이 사이즈를 **윈도우 사이즈**라고하고, 윈도우 사이즈만큼의 데이터를 한번에 보내도 오버플로 하지 않는것을 상대가 알수 있다
- 윈도우 사이즈는 확인 응답을 기다리지 않고 보낼수 있는 데이터 양이다
- 이런 일련의 과정을 **윈도우 제어**라고 한다

## 포트 번호

- IP, MAC주소만으로는 네트워크 컴퓨터만 식별가능 애플리케이션을 위한 가상의 출입구가 필요
- 포트 번호를 사용해 각각의 데이터가 어느 애플리케이션으로부터 송신 되었는지, 어느 애플리케이션 수신인지 결정
- 포트번호는 16비트가 있고 0~65535의 번호가 존재
- IP번호와 포트번호를 이용해서 어느 컴퓨터의 어느 애플리케이션인지 판별
- **수신처의 포트 번호를 모르면 데이터를 보낼수 없다**
- **수신 받을 애플리케이션이 포트와 접속해 있지 않으면, 데이터는 도달 불가**
- 송신처에서는 애플리케이션 서비스를 제공 받기위해 포트번호를 알아야하는데, 알수 있는 방법이 없다
- **자주 사용하는 서버 애플리케이션은 사전에 정해진 번호를 사용해 서비스를 제공한다**
- 이러한 번호를 **웰 노운 포트**(Well Know Port)라고 한다 **1~1023번**이 해당
  - 웹페이지는 보통 **80번 포트** (HTTP)
- 송신처의 포트는 1024~49151의 **등록된 포트**(사용자가 직접 등록해서 사용하는 포트)와 49152~65535의 **동적 포트**(수시로 변경되는 포트, 인터넷이나 시스템에서 동적으로 할당) 사용
  - 보통 웹서비스는 웹 브라우저에서 임의로 동적포트를 사용한다
- 포트 사용 조건은 다른 애플리케이션이 사용하고 있는 번호를 사용해서 안된다는 점외엔 없다
- 그러나 웹서비스같이 포트를 고객에게 하나하나 다 알려주고 싶지 않다면 일반적인 웰 노운 포트를 적용하는것이 옳다

# UDP

- **UDP**는 빠른 통신을 위한 프로토콜이다, 정확확실한 통신을 보장하지 않는다
- TCP는 정확확실을 목표로하는 프로토콜이다
- TCP의 치명적인 문제 **확인 응답을 기다리는 시간** = **일정 시간을 기다려야 한다**
- UDP의 헤더
  - 송신처 포트 번호 16비트
  - 수신처 포트 번호 16비트
  - 페이로드 사이즈 16비트
  - 체크섬 16비트
- UDP는 TCP와 달리 아무것도 하지 않는 프로토콜이다. 오직 포트번호로 전송만이 목적
  - 확인응답 X
  - 흐름제어 X
  - 에러복구 X
  - **고속성이나 실시간 송수신이 필요한 애플리케이션**
- UDP의 고속통신의 쓰이는곳
  - VoIP (Voice Over IP) : 인터넷 전화, 음성을 인터넷으로 보내는 기술
  - 동영상 스트리밍 배포 : 데이터를 스트리밍(흘러가도록) 연속적이며 계속 배포하는것
  - **브로드캐스트**가 필요한 애플리케이션
    - 브로드캐스트는 TCP로 통신이 어렵다
      - 다수와 커넥션을 확립해야하고
      - 다수와 통신할 버퍼를 준비해야한다 (윈도우 제어)
    - UDP로 통신한다면
      - 송신할 데이터가 1개로 끝나 대역소비 적음
      - 버퍼 유지 필요 X
      - 상대의 주소를 몰라도 송신 가능 (TCP는 커넥션 확립, 확인응답을 위해 주소를 특정해야함)
      - 예를 들어 DHCP(7계층) 메세지를 보낼때 본인 IP도 모르니 UDP로 DHCP DISCOVER 브로드캐스트 함
- UDP로는 시퀀스 제어를 어떻게 하나요?

# 네트워크 주소 변환

- **글로벌 IP주소**는 ICANN이 관리한다, 전세계에서 IP를 유일하게 관리하도록 하기 위해서
- 하지만 인터넷에 연결하지 않는다는 조건으로 자유롭게 사용가능한 **사설 IP 주소**도 존재한다
- 사설 IP주소 범위
  - 클래스 A : 10.0.0.0
  - 클래스 B : 172.16.0.0 ~ 172.31.0.0
  - 클래스 C : 192.168.0.0 ~ 192.168.255.0
- 인터넷에 접속하지 않고 TCP/IP를 사용할 경우에는 해당 IP들을 사용
- 인터넷에서는 데이터통신에서 글로벌 IP를 사용
- 문제점: 인터넷에 접속하는 기기 수가 너무 많아 **글로벌 IP의 주소가 부족하다**
  - 해결책 1 : 클래스리스 어드레싱
  - 해결책 2 : IPv6 사용 (Ipv4와 호환 X)
  - 해결책 3 : **네트워크 주소 변환**(**NAT**, Network Address Translation) (가장 간단하면서 유효한수단으로 사용되고 있다)

## NAT

- 인터넷에 접속하고 싶은 500대의 컴퓨터가 있다. 당신이 네트워크 관리자라면 어떻게 운영할것인가?
- 가장 쉬운 방법: 500개의 글로벌 IP를 할당받아 각각 배분
- IP주소가 모자라기떄문에 이렇게 많이 할당 받을수 없다. ISP에게 받을수 있는 IP주소는 10개 내외
- 먼저 **내부 네트워크에는 사설 IP주소를 할당한다**
- 사설 IP를 할당했기 때문에, 내부 네트워크 내에서 **TCP/IP를 사용한 통신**이 가능
- 내부망이더라도 TCP/IP 통신을 하기 위해서는 IP주소가 필요하기 때문에, 인터넷과 주고 받을 필요가 없더라도 IP주소가 필요하다
- NAT에 의해 내부 네트워크에서 할당한 사설 IP가 글로벌 IP로 변환된다
  1. 라우터에는 ICANN과 하부조직에 의해 할당된 글로벌 IP주소(200.100.10.1~15)가 주어져있다
  2. 내부 네트워크(사설 IP주소 192.168.0.1)에서 인터넷(글로벌 IP)에 송신한다
  3. 라우터는 NAT를 수행해 송신처 IP주소의 사설 IP주소를 글로벌 IP주소로 변경해 인터넷 수신처에 보낸다. 이 변경 사항은 NAT 테이블에 기록으로 남긴다
  4. 수신 받은 인터넷에 있는 서버는 응답한다. 물론 수신처는 아까 NAT로 변환된 글로벌 IP이다
  5. 패킷을 수신한 라우터는 NAT 테이블에 따라 수신처 글로벌 IP주소를 사설 IP 주소로 변경해 내부 네트워크에 송신한다
  6. NAT 테이블은 일정시간 후에 파기 된다
- **NAT의 단점** : **보유한 글로벌 IP 주소 수 이상의 호스트는 인터넷에 동시에 접속할 수 없다**
- 같은 글로벌 IP에 두개 이상의 사설 IP를 할당하면 되지 않는가? => 글로벌 IP로 들어온 수신이 어느 사설 IP로 가야하는지 구별 불가
- 즉 **NAT에서 변환되는 주소는 유일**해야한다
- 이러면 어차피 글로벌 IP가 많이 필요한 문제는 해결되지 않는것 아닌가? 맞다! (컴퓨터는 많은데 동시에 인터넷에 접속하는 호스트가 많지 않을 경우는 해결책이 될 수 있음, 그러나 요즘 컴퓨터는 인터넷 연결이 기본)
- 이런 문제를 해결하기위해 **NAPT** 등장

## NAPT (Network Address Port Translation)

- NAT는 사설 IP와 글로벌 IP를 1대1 매칭 시키는 단순 주소 변환 기술
- NAPT는 **하나의 글로벌 IP주소로 복수의 컴퓨터를 접속 가능**하게 하는 기술이다
- NAPT는 IP주소와 **포트 번호도 변환**해서 복수의 컴퓨터 접속을 가능하게 한다
- 과정
  1. NAPT는 NAT와 마찬가지로 IP주소를 변환하지만, IP주소를 변환할때 포트 번호도 변환하고 그 대응을 NAT 테이블에 기재한다
     - 192.168.0.1 1024번 포트 => 200.100.10.5 6001 포트로 변환
     - 192.168.0.2 1024번 포트 => 200.100.10.5 6002 포트로 변환
  2. 응답의 경우 IP주소와 포트 번호를 NAT 테이블에서 확인하고, IP 주소와 포트 번호를 변환
     - 200.100.10.5 6001 포트로 수신 => 192.168.0.1 1024번 포트로 변환
     - 200.100.10.5 6002 포트로 수신 => 192.168.0.2 1024번 포트로 변환
- 같은 IP주소로 들어와도 포트번호로 구분이 가능해진다!
- NAT(네트워크 주소 변환)은 IP 패킷에 적힌 소켓 주소의 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술이다. 패킷에 변화가 생기기 때문에 IP나 TCP/UDP의 체크섬(checksum)도 다시 계산되어 재기록해야 한다. 그렇기 때문에 네트워크의 성능(레이턴시)에 영향을 줄 수밖에 없다.
- **다른 장점** : **보안** 효과, NAT 테이블에 없는 변환은 변환되지 않기 떄문에 내부 네트워크에 침입할수 없다 (알고있는 IP의 포트에 무작위로 넣어서 들어가는게 대부분 불가능, 찍었는데 존재하면 어쩔수 없다)

## 정적 NAPT

- 보안효과는 장점이지만 **LAN 내부에서 외부로 공개하고 싶은 서버가 있을때** 문제가 발생
- 웹서버 같은 경우 외부에 특정 IP의 80번포트로 열어두고 싶은데, NAPT 테이블의 변환으로 해당 IP 80번 포트가 없다면 변환되지 않아 들어올수가 없다
- **NAPT 테이블에 저장되어 있지 않은 것은 LAN 내부에 들어오지 못한다** => 자동 파기
- 이런 경우 네트워크 관리자가 **NAPT 테이블에 미리 변환을 저장 시켜 준다** = **정적 NAPT**
- NAPT가 자동적으로 포트 변호를 변환하는것을 수동으로 입력해둔다

## NAPT의 단점

- FTP(File Transfer Protocol)같은 **데이터 부분에도 송신처 IP와 포트번호가 기술**되는 프로토콜에서 문제 발생
- IP헤더 TCP헤더에 수신처와 송신처의 IP주소, TCP 헤더에 수신처 송신처의 포트번호가 사용되는것은 수정이 가능하다 (체크섬도 포함)
- FTP같은 경우 데이터 부분에 있는 IP 주소와 포트 번호를 사용해 FTP 통신을 수행하는데, 사설 IP의 주소가 데이터 부분에 들어간 경우 당연히 인터넷을 이용한 파일 전송이 불가(글로벌 IP로 변환이 안된 상태니깐)
- 이런 **데이터 부분에서도 송신처의 IP주소와 포트 번호가 기술**되는 프로토콜들은 NAPT만으로 어쩔수가 없다. **NAPT를 수행하는 기기가 개별적으로 대응**해야 한다
