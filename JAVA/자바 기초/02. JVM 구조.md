# JVM

![JVM 구조](img/JVM-Architecture.png)

## JVM 동작순서 큰 그림

1. 자바로 개발된 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당
2. Class Loader를 통해 JVM Runtime Data Area로 로딩합니다.
3. Runtime Data Area에 로딩 된 .class들은 Execution Engine을 통해 해석합니다.
4. 해석된 바이트 코드는 Runtime Data Area의 각 영역에 배치되어 수행하며 이 과정에서 Execution Engine에 의해 GC의 작동과 스레드 동기화가 이루어집니다.

## 클래스 로더

- 자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행 중인 런타임에서야 모든 코드가 자바 가상 머신과 연결된다.
- 이렇게 동적으로 클래스를 로딩해주는 역할을 하는 것이 바로 **클래스 로더(class loader)**
- 자바에서 .java 소스파일을 작성하면 컴파일러가 컴파일을 통해 .class파일을 생성
- 클래스 로더는 .class 파일을 묶어서 JVM이 운영체제로부터 할당받은 메모리 영역인 Runtime Data Areas로 적재합니다.

## 런타임 데이터 영역 (Runtime Data Area)

- JVM의 메모리 영역으로 자바 애플리케이션이 실행될때 사용되는 데이터가 적재하는 영역
- 힙 영역과 메서드 영역은 모든 스레드가 공유한다
- 스택 영역과 PC 레지스터 네이티브 메서드 스택 영역은 스레드 하나마다 영역이 존재

## 실행 엔진 (Execution Engine)

- 클래스 로더에 의해 JVM으로 로드된 .class 파일(바이트코드)들은 Runtime Data Areas의 Method Area에 배치
- 배치된 이후에 JVM은 Method Area의 바이트 코드를 실행 엔진(Execution Engine)에 제공하여, 정의된 내용대로 바이트 코드를 실행
- 로드된 바이트코드를 실행하는 런타임 모듈이 **실행 엔진**(Execution Engine), 실행 엔진은 바이트코드를 명령어 단위로 읽어서 실행합니다.

## 가비지 컬렉터 (gabage Collector)

자바 가상 머신은 가비지 컬렉터(garbage collector)를 이용하여 더는 사용하지 않는 메모리를 자동으로 회수해 줍니다. 따라서 개발자가 따로 메모리를 관리하지 않아도 되므로, 더욱 손쉽게 프로그래밍을 할 수 있도록 도와줍니다. Heap 메모리 영역에 생성(적재)된 객체들 중에 참조되지 않은 객체들을 탐색 후 제거하는 역할을 하며 해당 역할을 하는 시간은 정확히 언제인지를 알 수 없습니다. GC역할을 수행하는 스레드를 제외한 나머지 모든 스레드들은 일시정지상태가 됩니다.
