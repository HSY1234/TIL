# JAVA

> Write once, Run anywhere

- 자바는 사람이 이해할수 있는 고급언어
- 1995년도에 처음 썬 마이크로시스템즈에서 발표한후, 가장 성공한 프로그래밍 언어중 하나. 창시자는 제임스 고슬링
- 안드로이드 애플리케이션, 데스크톱 애플리케이션, 웹사이트를 개발하는 핵심언어로 사용
- 자바는 오라클에서 라이선스를 가지고 있다. 오라클은 자바 개발 도구 (Java Development Kit, JDK)를 배포하여 자바로 프로그램을 쉽게 개발할수 있도록 기술적 지원을 하고 있다

## 자바의 역사

- 1991년 썬의 엔지니어들에 의해 고안된 오크(Oak)라는 언어에서 시작
- 원래 목표는 C++를 확장해 가전제품에 탑재될 소프트웨어를 만드는것
- C++의 한계떄문에 C++의 장점을 도입하고 단점을 보완한 새로운 언어를 개발
- OAK는 처음에는 PDA나 가전제품같은 소형기기에 사용될 목적이였으나 여러 종류의 운영체제를 사용하는 컴퓨터들이 통신하는 인터넷이 등장하자 운영체제에 독립적인 OAK를 인터넷에 적합하도록 개발 방향을 변경후 이름을 JAVA라고함
- 자바로 개발한 웹브라우저 핫 자바를 발표
- 당시 자바로 작성된 Applet은 정적인 웹페이지에 사운드와 애니메이션등의 멀티미디어적인 요소들을 제공 할 수 있는 유일한 방법이었기 때문에 많은 인기를 얻음
- 현재는 보안상의 이유로 최신 웹브라우저에서 애플릿을 지원하지 않는다
- 그러나 서버쪽 프로그래밍을 위한 Servlet과 JSP가 더 많이 이용되고, 모바일 안드로이드에서 JAVA를 사용
- 안드로이드는 오라클의 자바 라이선스를 피하기 위해 별도의 개발 도구를 사용, Dalvik이라는 새로운 자바 가상 기계를 시작으로 현재는 Android RunTime을 줄여서 ART같은 런타임 VM을 사용한다

## 자바의 장점

- 모든 운영체제에서 실행가능 (운영체제 독립적)
  - 일종의 에뮬레이터인 JVM과 통신을 통해 운영체제가 이해할수 있도록 변환되어 전달
- 객체지향 프로그래밍
- 메모리 자동정리
- 무료 라이브러리 풍부
- 자동 메모리 관리(Garbage Collection)
- 네트워크와 분산처리 지원
  - 다양한 네트워크 프로그래밍 라이브러리 java API를 지원
- 멀티쓰레드 지원
  - 자바의 멀티스레드 라이브러리가 제공되므로 구현이 쉽다. 쓰레드에 대한 스케줄링은 자바 인터프리터가 담당한다
  - 멀티스레드 프로그램을 작성하기 위해서는, 운영체제가 멀티스레드를 지원하고 멀티스레드와 관련된 API나 라이브러리를 제공해야한다
  - C나 C++등 많은 언어들이 자체적으로 멀티스레드를 지원하지 않아 운영체제의 도움을 받는다 (최근에는 지원)
  - 멀티스레드를 지원하지 않는 운영체제에서도 자바를 이용해 멀티스레드 프로그램 개발가능 (사용자 수준의 멀티스레드)
- 동적 로딩 지원
  - 모든 클래스가 실행시 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할수 있다
  - 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 되며, 적은 작업만으로 처리 가능

## 자바의 단점

- 속도문제
- 결국 바이트 코드를 기계어로 변환하는 인터프리터 과정이 필요
- 바이트코드를 하드웨어의 기계어로 변환해주는 JIT컴파일러와 Hotspot같은 신기술의 도입으로 JVM의 기능 향상으로 속도문제 개선

## 자바의 배포판 분류

- Java는 크게 다음과 같은 3가지 에디션으로 나뉜다.
- Java SE(Java Standard Edition / J2SE)  
  대부분의 사람들이 가장 많이 접하는 표준 에디션. Java의 핵심 API와 기능들을 제공한다. JDK는 Java SE 스펙을 준수해서 만든다
- Jakarta EE, 구 Java EE(Java Enterprise Edition / J2EE)  
  기업에서 운영하는 서버 페이지에 특화된 에디션이다. JSP와 서블릿을 비롯한 웹 애플리케이션 서버에 관련된 기술들이 포함되어 있다
- Java ME(Java Micro Edition / J2ME)  
  피처폰, PDA, 셋톱박스, 센서 등의 임베디드 시스템 환경에 특화된 경량 에디션이다

## JAVA 용어 정리

- JAVA17을 씁니다!의 의미
- Java 개발 도구에 중점 : JDK 17
- Java 실행 환경에 중점 : JRE 17
- Java 스펙 내용에 중점 : JavaSE-17
- JDK : 자바 개발도구
- JRE : 자바 실행환경, 자바로 작성된 응용프로그램이 실행되기 위한 최소한의 환경
- JDK = JRE + 개발에 필요한 실행파일(javac.exe 등등)
- JRE = JVM + 표준 자바 클래스 라이브러리(Java API)

![JDK 구조](img/JDK%20strurcture.png)

# JVM(JAVA Virtual Machine)

- 자바를 실행하기 위한 가상 기계(컴퓨터)
- 가상 기계란 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어
- 컴퓨터의 성능이 향상됨에 따라 점점 더 많은 하드웨어들이 소프트웨어화되어 컴퓨터 속으로 들어오고 있다
- 자바로 작성된 애플리케이션은 모둥 JVM에서만 실행되기 때문에, 자바를 실행하기위해선 JVM은 필수
- 즉 일반 애플리케이션의 코드는 OS를 거쳐 하드웨어로 전달되는데, Java 애플리케이션은 OS전에 JVM을 거친다
- 자바 바이트 코드(.class 파일)을 OS에 특화된 코드로 변환 (**인터프리터**와 **JIT 컴파일러**의 조합)
- 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시에 해석(interpret)되기 때문에 속도가 느리다는 단점을 가지고 있다.
- 최근에는 바이트 코드를 하드웨어의 기계어로 바로 변환해주는 **JIT 컴파일러**와 향상된 최적화 기술이 적용되어서 속도가 많이 빨라졌다
- JVM은 운영체제와 맞붙어 있기 때문에, OS에 종속적이다
- JVM은 클래스 파일에 있는 바이트 코드를 하나씩 실행한다. JVM은 실행중, JDK 라이브러리에 들어있는 다른 클래스 파일이나 사용자가 작성한 다른 클래스 파일이 필요하다면 그 때 **클래스 파일을 로딩**하고 실행한다. 대부분의 자바 가상 기계는 실행중에 JDK 라이브러리 로딩으로 인한 시간 지연을 줄이기 위해 자바 프로그램 실행전 JDK 라이브러리를 미리 로딩해둔다.
- 따라서 자바에서는 C같은 **링크(link) 과정이 없다!** => 대신 **클래스 로더** (링킹 같은 방식은 존재)
- 바이트 코드를 실행하는 표준(JVM 자체는 표준)이자 구현체이다
- JVM 스펙: https://docs.oracle.com/javase/specs/jvms/se11/html/
- JVM의 벤더 : 오라클, Azul 등등

## JVM 언어?

- JVM 기반으로 동작하는 프로그래밍 언어
- 코틀린, 스칼라, 클로저, 그루비, Jython, JRuby, 실론, 프레게, 에타 등등
- https://www.itworld.co.kr/news/109008

# JRE (Java Runtime Environment)

- JVM + 라이브러리
- JVM과 핵심 라이브러리와 자바 런타임 환경에 사용하는 프로퍼티 세팅이나 리소스 파일을 포함
- 즉 개발 관련 도구는 따로 제공 X => JDK가 가지고 있다

# JDK (Java Development Kit)

- 썬 마이크로시스템즈에서 개발한 Java 환경에서 돌아가는 프로그램을 개발하는 데 필요한 툴들을 모아놓은 소프트웨어 패키지이다. JRE(Java Runtime Environment)와 Java 바이트코드 컴파일러, Java 디버거 등을 포함하는 개발 도구들로 이루어져 있다. IBM에서 자체적으로 변형한 IBM JDK와 오픈 소스 버전인 OpenJDK도 있다.
- JRE + 개발자 툴
- JDK를 설치하면 JVM, 자바클래스 라이브러리(Java API)외에 필요한 프로그램들이 설치된다

## JDK 종류

자바는 워낙에 유명한 프로그래밍 언어이기 때문에 JDK도 여러가지 종류로 나뉜다

여러가지 JDK가 있는 큰 이유는 라이센스 때문이다.

Java 소스코드 자체는 오픈소스이다.

그래서 오픈소스인 Java 소스코드를 빌드하여 사용하는 것에는 거의 제약이 없지만 Oracle에서 제공하는 설치버전의 JDK에는 위의 NFTC 라이센스가 적용되어 회사에서는 사용할 수 없게 된다.

그래서 무료 라이센스를 제공하는 또다른 JDK 버전을 여러 회사에서 출시했고 지금의 JDK 환경이 갖춰진 것이다.

- Oracle JDK : Oracle에서 제공하는 JDK. 구독을 통해 유료 라이센스를 구매할 수 있다. (11부터 JRE는 제공 안함, Oracle JDK 11 버전부터 상용시 유료)
- Open JDK : 유명한 무료 JDK.
- Azul Zulu : 인지도가 높은 JDK 중 하나이며, Mac 등에서 사용할 수 있는 바이너리를 제공하는 것이 특징이다.
- Amazon Corretto : AWS에서 제공하는 JDK. AWS에서 쉽게 사용 가능하며, AWS 환경이 아니더라도 사용할 수 있다.
- Temurin (AdoptOpenJDK) : Eclipse에서 제공하는 JDK. Eclipse를 사용한다면 Temurin 설치를 추천한다.

## JDK 폴더 구조

- bin : 자바 개발 실행하는데 필요한 도구와 유틸리티, 자바 클래스 파일을 해석하고 실행하는데 필요한 소프트웨어를 둔다
  - javac : 자바 소스를 바이트 코드로 변환하는 컴파일러
  - java : jre의 bin 디렉터리에도 동시에 설치되어 있는 **자바 응용프로그램 실행기**, 이 도구를 통해 자바 가상 기계가 작동하며 자바 프로그램 실행
  - javadoc : 자바 소스 프로그램으로부터 HTML 형식의 API 도큐먼트 생성
  - jar : 자바 클래스 파일을 압축한 자바 아카이브 파일 JAR을 생성하고 관리하는 유틸리티
  - jdb : 자바 응용프로그램의 실행 중 오류를 찾는데 사용하는 디버거
  - javap : 클래스 파일에 담긴 바이트 코드를 자바 소스와 함께 보여주는 디 어셈블러
  - appletviewer : 웹 브라우저 없이 애플릿 응용프로그램을 실행하고 디버깅하는 유틸리팅
- db : 자바로 DB 응용프로그램을 개발하는데 필요한 도구
- demo : 자바 프로그래밍 데모 예제와 소스 코드
- include : 네이티브 코드 프로그래밍에 필요한 C언어 헤더 파일
- jre : 자바 런타임 환경, JVM, 클래스 라이브러리 등 실행에 필요한 파일
- lib : JDK의 기본 라이브러리 외 추가 클래스 라이브러리와 개발 도구에서 필요로 하는 여러 파일, 미리 컴파일 한 자바 API 라이브러리들을 추가로 둘 수 있다
- sample : 자바 프로그램 샘플 소스 코드
- src.zip : 자바 API 클래스들에 대한 자바 소스

## 자바 API

- 자바에서 서로 관련된 클래스들을 분류하여 묶어놓은 것을 **패키지**라고 한다
- **자바 API**란 오라클 사에서 제공하는 것으로 주요한 기능들을 미리 구현한 클래스 라이브러리로 묶어놓은 패키지
- 필요한 기능을 포함한 패키지만 import하여 사용하면 된다
- 흔히 말하는 자바 공식 API문서는 이 API 사용법에 대한 문서이다, 온라인이나 다운로드로 제공됨

## 버전별 JDK

- 자바 프로그램을 실행하고 실행하기 위해서는 먼저 Java SE의 구현체인 JDK를 설치해야한다
- 많이 쓰는 JDK로는 Open JDK 와 Oracle JDK가 있다
- Open JDK는 무료로 사용가능하고, Oracle JDK는 학습용은 무료지만 상업용은 유료다
- JDK LTS(Long Term Support)는 장기간 기술 지원을 받을수 있기 때문에 다른 버전보다 안정적으로 사용가능
- JDK 8, 11, 17이 LTS버전이며, 이 버전으로 개발 및 실행하는것이 좋다

## 윈도우 환경변수 설정

- 운영체제는 프로그램들이 실행하면서 사용할 수 있는 값들을 환경 변수 이름으로 관리한다
- JDK를 설치하고 나면 프로그램들이 JDK를 이용할 수 있도록 JAVA_HOME 환경 변수를 생성하고, Path 환경 변수를 수정하는 것이 좋다
- 자바 실행파일의 경로가 환경변수 path에 제대로 세팅되어 있다면 어느 곳에서나 jdk의 bin에 있는 프로그램들을 실행시킬 수 있다. 즉 자바를 설치한 후 환경변수를 설정해줘야 하는 이유는 운영체제 어디에서든지 자바를 인식할 수 있도록 하는 것이 목적, 특히 jdk bin폴더에 있는 javac 컴파일러의 경우 .java 파일을 jvm에서 실행시킬 수 있는 .class 파일로 컴파일해주는 중요한 프로그램인데 환경변수 세팅이 제대로 안되어있으면 이클립스와 같은 IDE에서 컴파일이 제대로 안 되는 현상이 발생 그렇기 때문에 자바 환경 변수를 설정할 때 jdk의 bin 디렉터리 경로를 등록하게 된다. bin 폴더 안에 javac를 비롯한 각종 실행파일이 있기 때문

1. 내 PC 들어가서 우클릭 => 속성
2. 고급 시스템 설정 클릭
3. 환경변수 클릭
4. 시스템 변수에서 새로 만들기 클릭후 변수 이름 JAVA_HOME, 변수값 JDK가 설치된 폴더 경로 선택 후 확인
5. 시스템 변수에서 Path 변수를 찾아 편집 클릭
6. 새로 만들기 클릭하고 추가된 항목에 직접 `%JAVA_HOME%\bin` 입력 (`%JAVA_HOME%`는 JAVA_HOME 환경변수의 값을 의미 즉, JAVA_HOME/bin은 jdk의 bin 폴더이다)
7. 위로 이동을 눌러 최상위로 올려서 java 명령어가 먼저 bin 파일 찾도록 설정
8. 프롬프트를 새로 실행해 `javac -version`입력후 정상 실행 확인

## 환경 설정중 알면 좋은것

환경 변수

- 사용자 변수
  - 로그인한 사용자에 대한 변수
  - 다른 사용자와 공유되지 않는다
- 시스템 변수

  - 모든 사용자가 공유
  - JDK같은 경우 시스템 변수에 세팅하는것을 권장

- Path 환경변수의 역할  
  어떤 실행파일을 실행 하는데 있어 해당 위치에 파일이 없으면 컴퓨터는 2차적으로 Path경로에서 실행 파일을 찾아 실행한다.

- javac.exe 란?  
  자바 컴파일러( JAVA Compiler )를 이야기하며, 자바코드를 작성한 소스파일( .java )을 자바 가상 머신( JVM )이 인식할 수 있는 바이트 코드( .class ) 타입으로 변환시켜주는 역할을 한다.

- java.exe 란?  
  자바 인터프리터( JAVA Interpreter )라고 하며, 자바 프로그램( .class )을 실행시킨다.

- javap.exe 란?  
  자바 역어셈블러, 컴파일된 클래스파일을 원래의 소스로 변환한다

- javadoc.exe 란?  
  자동문서 생성기, 소스파일에 있는 특정 주석(`/** ··· */` )을 이용하여 Java API문서와 같은 형식의 문서를 자동으로 생성한다

- jar.exe 란?  
  압축프로그램, 클래스파일과 프로그램의 실행에 관련된 파일을 하나의 jar파일로 압축하거나 압축해제

- 왜 CLASSPATH는 설정하지 않나요?  
  CLASSPATH 환경변수는 자바 클래스로더가 기본적으로 바라보는 경로, java 라이브러리를 사용하기 위해 설정하는 환경변수인 CLASSPATH를 설정하면 모든 자바 프로그램이 같은 버전의 라이브러리를 공유  
  그러나 J2JDK 버전부터는 \jre\lib\ext 폴더에 필요한 클래스 라이브러리들을 복사해 놓으면 사용가능하여 특별한 경우가 아니면 설정을 하지 않는다  
  자바 웹 애플리케이션을 실행할 수 있는 톰캣의 경우 CLASSPATH 환경변수를 무시하고 별도의 경로를 클래스패스로 잡도록 되어있다

# 바이트코드 파일과 컴파일 과정

- JDK가 설치됐다면 자바 언어로 작성한 소스 파일을 만들고 컴파일할 수 있다
- 자바 소스 파일의 확장자는 .java
- .java 파일을 작성한후 javac(java compiler) 명령어로 소스파일을 컴파일하면 .class인 바이트 코드(ByteCode) 파일이 생성된다
- 바이트 코드는 플랫폼에 대한 종속성이 없이 자바 JVM에서 실행되는 코드이다
- 바이트코드 파일을 특정 운영체제가 이해하는 기계어로 번역하고 실행시키는 명령어는 java이다
- java 명령어는 JDK와 함께 설치된 자바 가상 머신(JVM)을 구동시켜 바이트코드 파일을 완전한 기계어로 번역(인터프리터 방식)하고 실행시킨다
- 바이트코드 파일은 운영체제와 상관없이 모두 동일한 내용으로 생성되지만, 자바 가상 머신은 운영체제에서 이해하는 기계어로 번역해야 하므로 운영체제마다 다르다(그래서 JDK가 운영체제마다 다름)

- 자바 코드

```java
for (int i = 2; i < 1000; i++) {
    for (int j = 2; j < i; j++) {
        if (i % j == 0)
            continue outer;
    }
    System.out.println (i);
}
```

- 바이트 코드

```
0:   iconst_2
1:   istore_1
2:   iload_1
3:   sipush  1000
6:   if_icmpge       44
9:   iconst_2
10:  istore_2
11:  iload_2
12:  iload_1
13:  if_icmpge       31
16:  iload_1
17:  iload_2
18:  irem
19:  ifne    25
22:  goto    38
25:  iinc    2, 1
28:  goto    11
31:  getstatic       #84; // Field java/lang/System.out:Ljava/io/PrintStream;
34:  iload_1
35:  invokevirtual   #85; // Method java/io/PrintStream.println:(I)V
38:  iinc    1, 1
41:  goto    2
44:  return
```

## 소스코드를 CLI 환경에서 실행해보자

1. temp 폴더에 src폴더와 bin폴더가 있다고 가정
2. src폴더에 Hello.java 작성
3. `java -d [바이트코드파일저장위치] [소스경로/*.java]` 실행 => 컴파일러가 컴파일해주세요
   - javac -d bin src/Hello.java
4. bin 폴더에 Hello.class 바이트코드 파일 생성을 확인
5. `java -cp [바이트코드파일위치] [패키지···클래스명](.class는 생략)` 실행 => JVM으로 실행해주세요
   - java -cp bin Hello
   - Hello World! 출력됨

# 자바 프로그램을 시작하기 전에

- 자바에서 import문과 package문을 제외한 모든 코드는 클래스 안에 존재해야하며 (캡슐화), 서로 관련된 코드들을 그룹으로 나누어 별도의 클래스로 구성하게 된다
- 자바의 package는 자바만의 독특한 개념이다, 서로 관련있는 클래스는 패키지로 묶어 관리한다, 패키지는 **파일시스템의 폴더 개념**과 같다
- main 함수는 프로그램을 실행할때 java.exe에 의해 호출될수 있는 entry point이다, java 프로그램은 main메서드의 호출로 시작해 main 메서드의 마지막 문장까지 수행을 마치면 종료된다
- 모든 클래스가 main 메서드를 가지고 있어야 하는 것은 아니지만, 하나의 Java 애플리케이션은 main 메서드를 포함한 클래스가 반드시 하나 있어야 한다
- 하나의 소스파일에 하나의 클래스만을 정의하는 것이 보통이지만, 하나의 소스파일에 둘 이상의 클래스를 정의하는 것도 가능하다
- **자바의 소스파일의 이름은 public class의 이름과 일치해야한다**, 만약 소스파일내에 public class가 없다면, 소스파일의 이름은 소스파일 내의 어떤 클래스의 이름으로 해도 상관없다
- 이렇게 디자인 된 이유는 JVM이 진입점을 인식하기 위해서다. .java 파일과 .class 바이트 코드 파일 이름이 같은데, 자바 인터프리터가 진입점 클래스를 파악하기 쉽게 하기 위해서이다 + 가독성을 위한 제임스 고슬링의 철학
- 따라서 한 소스파일안에서 **public class**는 유일하며 파일 이름과 같다! (public class가 아예 없을순 있다)
- 소스 파일과 달리 클래스 파일은 **클래스마다 하나씩** 만들어진다
- 이는 **내부 클래스**도 마찬가지 이다, 클래스 C 내부에 클래스 D가 존재할 경우, `C$D.class` 이름의 바이트코드 파일 생성

## 자바 프로그램의 실행과정

1. `java Hello` CLI에서 입력
2. 프로그램 실행에 필요한 클래스 파일을 로드
3. 클래스파일을 검사한다 (파일형식 등)
4. 지정된 클래스에서 main(String[] args)를 호출한다

# 주석

- 행주석: `//`, 행끝까지 주석으로 처리
- 범위 주석 : `/* ··· */` , 사이에 있는 내용은 모두 주석
- 도큐먼트 주석 : `/** ··· */` , 사이에 있는 내용은 모두 주석 javadoc 명령어로 API 도큐먼트 생성하는데 사용
